<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.example&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.empresa.course&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;MicroserviceCourseApi&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;MicroserviceCourseApi&lt;/name&gt;&#10;&#9;&lt;description&gt;microservicio encargado de gestionar los profesores y alumnos de los cursos&lt;/description&gt;&#10;&#9;&lt;url/&gt;&#10;&#9;&lt;licenses&gt;&#10;&#9;&#9;&lt;license/&gt;&#10;&#9;&lt;/licenses&gt;&#10;&#9;&lt;developers&gt;&#10;&#9;&#9;&lt;developer/&gt;&#10;&#9;&lt;/developers&gt;&#10;&#9;&lt;scm&gt;&#10;&#9;&#9;&lt;connection/&gt;&#10;&#9;&#9;&lt;developerConnection/&gt;&#10;&#9;&#9;&lt;tag/&gt;&#10;&#9;&#9;&lt;url/&gt;&#10;&#9;&lt;/scm&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.example&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.empresa.course&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;MicroserviceCourseApi&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;MicroserviceCourseApi&lt;/name&gt;&#10;&#9;&lt;description&gt;microservicio encargado de gestionar los profesores y alumnos de los cursos&lt;/description&gt;&#10;&#9;&lt;url/&gt;&#10;&#9;&lt;licenses&gt;&#10;&#9;&#9;&lt;license/&gt;&#10;&#9;&lt;/licenses&gt;&#10;&#9;&lt;developers&gt;&#10;&#9;&#9;&lt;developer/&gt;&#10;&#9;&lt;/developers&gt;&#10;&#9;&lt;scm&gt;&#10;&#9;&#9;&lt;connection/&gt;&#10;&#9;&#9;&lt;developerConnection/&gt;&#10;&#9;&#9;&lt;tag/&gt;&#10;&#9;&#9;&lt;url/&gt;&#10;&#9;&lt;/scm&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Kafka --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Security --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Validation --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/CourseController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/CourseController.java" />
              <option name="originalContent" value="package com.empresa.course.MicroserviceCourseApi.Controller;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Course;&#10;import com.empresa.course.MicroserviceCourseApi.Service.Inter.ICourseService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/courses&quot;)&#10;public class CourseController {&#10;&#10;    @Autowired&#10;    private ICourseService courseService;&#10;&#10;    @PostMapping(&quot;/save&quot;)&#10;    @ResponseStatus(HttpStatus.CREATED)&#10;    public void save(@RequestBody Course course) {&#10;        courseService.save(course);&#10;    }&#10;&#10;    @GetMapping(&quot;/findAll&quot;)&#10;    public ResponseEntity&lt;?&gt; findAll() {&#10;        return ResponseEntity.ok(courseService.findAll());&#10;    }&#10;&#10;    @GetMapping(&quot;/findById/{id}&quot;)&#10;    public ResponseEntity&lt;?&gt; findById(@PathVariable Long id) {&#10;        return ResponseEntity.ok(courseService.findById(id));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{id}&quot;)&#10;    public void delete(@PathVariable Long id) {&#10;        courseService.DeleteById(id);&#10;    }&#10;&#10;    @GetMapping(&quot;/search-student-teacher/{idCourse}&quot;)&#10;    public ResponseEntity&lt;?&gt; findStudentsAndTeachersByCourse(@PathVariable Long idCourse) {&#10;        return ResponseEntity.ok(courseService.getStudentsAndTeachersByCourse(idCourse));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Controller;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Controller.DTO.CourseRequest;&#10;import com.empresa.course.MicroserviceCourseApi.Controller.DTO.CourseResponse;&#10;import com.empresa.course.MicroserviceCourseApi.Controller.DTO.RoutePlanRequest;&#10;import com.empresa.course.MicroserviceCourseApi.Controller.DTO.RoutePlanResponse;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.RoutePlan;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Turno;&#10;import com.empresa.course.MicroserviceCourseApi.Service.Impl.CourseService;&#10;import com.empresa.course.MicroserviceCourseApi.Service.Impl.RoutePlannerService;&#10;import com.empresa.course.MicroserviceCourseApi.Service.Impl.ScheduleOrganizerService;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.format.annotation.DateTimeFormat;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/courses&quot;)&#10;@RequiredArgsConstructor&#10;public class CourseController {&#10;&#10;    private final CourseService courseService;&#10;    private final RoutePlannerService routePlannerService;&#10;    private final ScheduleOrganizerService scheduleOrganizerService;&#10;&#10;    // ==================== CRUD de Cursos ====================&#10;&#10;    @GetMapping&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER', 'STUDENT')&quot;)&#10;    public ResponseEntity&lt;List&lt;CourseResponse&gt;&gt; findAll() {&#10;        return ResponseEntity.ok(courseService.findAll());&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER', 'STUDENT')&quot;)&#10;    public ResponseEntity&lt;CourseResponse&gt; findById(@PathVariable Long id) {&#10;        return ResponseEntity.ok(courseService.findById(id));&#10;    }&#10;&#10;    @PostMapping&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;CourseResponse&gt; create(@Valid @RequestBody CourseRequest request) {&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(courseService.create(request));&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;CourseResponse&gt; update(@PathVariable Long id,&#10;                                                  @Valid @RequestBody CourseRequest request) {&#10;        return ResponseEntity.ok(courseService.update(id, request));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; delete(@PathVariable Long id) {&#10;        courseService.delete(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    // ==================== Búsquedas ====================&#10;&#10;    @GetMapping(&quot;/type/{courseType}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;CourseResponse&gt;&gt; findByCourseType(@PathVariable CourseType courseType) {&#10;        return ResponseEntity.ok(courseService.findByCourseType(courseType));&#10;    }&#10;&#10;    @GetMapping(&quot;/turno/{turno}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;CourseResponse&gt;&gt; findByTurno(@PathVariable Turno turno) {&#10;        return ResponseEntity.ok(courseService.findByTurno(turno));&#10;    }&#10;&#10;    @GetMapping(&quot;/active&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;CourseResponse&gt;&gt; findActive() {&#10;        return ResponseEntity.ok(courseService.findActive());&#10;    }&#10;&#10;    @GetMapping(&quot;/teacher/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;CourseResponse&gt;&gt; findByTeacherId(@PathVariable Long teacherId) {&#10;        return ResponseEntity.ok(courseService.findByTeacherId(teacherId));&#10;    }&#10;&#10;    @GetMapping(&quot;/student/{studentId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER', 'STUDENT')&quot;)&#10;    public ResponseEntity&lt;List&lt;CourseResponse&gt;&gt; findByStudentId(@PathVariable Long studentId) {&#10;        return ResponseEntity.ok(courseService.findByStudentId(studentId));&#10;    }&#10;&#10;    // ==================== Gestión de profesores y estudiantes ====================&#10;&#10;    @PostMapping(&quot;/{courseId}/assign-teacher/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; assignTeacher(@PathVariable Long courseId,&#10;                                               @PathVariable Long teacherId) {&#10;        courseService.assignTeacher(courseId, teacherId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{courseId}/remove-teacher/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; removeTeacher(@PathVariable Long courseId,&#10;                                               @PathVariable Long teacherId) {&#10;        courseService.removeTeacher(courseId, teacherId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @PostMapping(&quot;/{courseId}/enroll/{studentId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; enrollStudent(@PathVariable Long courseId,&#10;                                               @PathVariable Long studentId) {&#10;        courseService.enrollStudent(courseId, studentId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{courseId}/unenroll/{studentId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; unenrollStudent(@PathVariable Long courseId,&#10;                                                 @PathVariable Long studentId) {&#10;        courseService.unenrollStudent(courseId, studentId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @PatchMapping(&quot;/{courseId}/activate&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; activateCourse(@PathVariable Long courseId,&#10;                                                @RequestParam boolean active) {&#10;        courseService.activateCourse(courseId, active);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    // ==================== Planificador de rutas ====================&#10;&#10;    @PostMapping(&quot;/generate-route&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;RoutePlanResponse&gt; generateRoute(@Valid @RequestBody RoutePlanRequest request) {&#10;        RoutePlan plan = routePlannerService.generateRoutePlan(&#10;                request.getCourseId(),&#10;                request.getCourseType(),&#10;                request.getWindDirection(),&#10;                request.getWindSpeedKnots(),&#10;                request.getClassDurationMinutes(),&#10;                request.getStudentLevel()&#10;        );&#10;        return ResponseEntity.ok(toRoutePlanResponse(plan));&#10;    }&#10;&#10;    @PostMapping(&quot;/{courseId}/generate-route&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;RoutePlanResponse&gt; generateRouteForCourse(&#10;            @PathVariable Long courseId,&#10;            @Valid @RequestBody RoutePlanRequest request) {&#10;        request.setCourseId(courseId);&#10;        RoutePlan plan = routePlannerService.generateRoutePlan(&#10;                courseId,&#10;                request.getCourseType(),&#10;                request.getWindDirection(),&#10;                request.getWindSpeedKnots(),&#10;                request.getClassDurationMinutes(),&#10;                request.getStudentLevel()&#10;        );&#10;        return ResponseEntity.ok(toRoutePlanResponse(plan));&#10;    }&#10;&#10;    // ==================== Organizador de horarios ====================&#10;&#10;    @PostMapping(&quot;/organize-week&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;?&gt; organizeWeekSchedule(&#10;            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate weekStartDate) {&#10;        var schedules = scheduleOrganizerService.organizeWeekSchedule(weekStartDate);&#10;        return ResponseEntity.ok(schedules);&#10;    }&#10;&#10;    @PostMapping(&quot;/reorganize-day&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;?&gt; reorganizeDaySchedule(&#10;            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date) {&#10;        var schedules = scheduleOrganizerService.reorganizeDaySchedule(date);&#10;        return ResponseEntity.ok(schedules);&#10;    }&#10;&#10;    @GetMapping(&quot;/available-slots&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;?&gt; getAvailableSlots(&#10;            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date,&#10;            @RequestParam Turno turno) {&#10;        var slots = scheduleOrganizerService.getAvailableSlots(date, turno);&#10;        return ResponseEntity.ok(slots);&#10;    }&#10;&#10;    @GetMapping(&quot;/occupancy-stats&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;?&gt; getWeekOccupancyStats() {&#10;        return ResponseEntity.ok(scheduleOrganizerService.getWeekOccupancyStats());&#10;    }&#10;&#10;    // ==================== Helpers ====================&#10;&#10;    private RoutePlanResponse toRoutePlanResponse(RoutePlan plan) {&#10;        return RoutePlanResponse.builder()&#10;                .id(plan.getId())&#10;                .courseId(plan.getCourseId())&#10;                .courseType(plan.getCourseType())&#10;                .windDirection(plan.getWindDirection())&#10;                .windSpeedKnots(plan.getWindSpeedKnots())&#10;                .classDurationMinutes(plan.getClassDurationMinutes())&#10;                .studentLevel(plan.getStudentLevel())&#10;                .createdAt(plan.getCreatedAt())&#10;                .summary(plan.getSummary())&#10;                .safetyNotes(plan.getSafetyNotes())&#10;                .imageBase64(plan.getImageBase64())&#10;                .legs(plan.getLegs().stream()&#10;                        .map(leg -&gt; RoutePlanResponse.RouteLegResponse.builder()&#10;                                .order(leg.getOrder())&#10;                                .maneuverType(leg.getManeuverType())&#10;                                .heading(leg.getHeading())&#10;                                .durationMinutes(leg.getDurationMinutes())&#10;                                .distanceMeters(leg.getDistanceMeters())&#10;                                .description(leg.getDescription())&#10;                                .build())&#10;                        .collect(Collectors.toList()))&#10;                .build();&#10;    }&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/CourseRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/CourseRequest.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Controller.DTO;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Turno;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class CourseRequest {&#10;&#10;    @NotBlank(message = &quot;El nombre es obligatorio&quot;)&#10;    private String name;&#10;&#10;    private String description;&#10;&#10;    @NotNull(message = &quot;El turno es obligatorio&quot;)&#10;    private Turno turno;&#10;&#10;    @NotNull(message = &quot;El tipo de curso es obligatorio&quot;)&#10;    private CourseType courseType;&#10;&#10;    private Integer durationMinutes;&#10;&#10;    private Integer maxStudents;&#10;&#10;    private LocalDate startDate;&#10;&#10;    private LocalDate endDate;&#10;&#10;    private LocalTime startTime;&#10;&#10;    private LocalTime endTime;&#10;&#10;    private Set&lt;Long&gt; teacherIds;&#10;&#10;    private Set&lt;Long&gt; studentIds;&#10;&#10;    private Double price;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/CourseResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/CourseResponse.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Controller.DTO;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Turno;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class CourseResponse {&#10;    private Long id;&#10;    private String name;&#10;    private String description;&#10;    private String status;&#10;    private Turno turno;&#10;    private CourseType courseType;&#10;    private Integer durationMinutes;&#10;    private Integer maxStudents;&#10;    private LocalDate startDate;&#10;    private LocalDate endDate;&#10;    private LocalTime startTime;&#10;    private LocalTime endTime;&#10;    private Set&lt;Long&gt; teacherIds;&#10;    private Set&lt;Long&gt; studentIds;&#10;    private Double price;&#10;    private Boolean active;&#10;    private Integer currentStudents;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/RoutePlanRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/RoutePlanRequest.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Controller.DTO;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.WindDirection;&#10;import jakarta.validation.constraints.Max;&#10;import jakarta.validation.constraints.Min;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class RoutePlanRequest {&#10;&#10;    private Long courseId;&#10;&#10;    @NotNull(message = &quot;El tipo de clase es obligatorio&quot;)&#10;    private CourseType courseType;&#10;&#10;    @NotNull(message = &quot;La dirección del viento es obligatoria&quot;)&#10;    private WindDirection windDirection;&#10;&#10;    @Min(value = 1, message = &quot;La velocidad del viento debe ser al menos 1 nudo&quot;)&#10;    @Max(value = 50, message = &quot;La velocidad del viento no puede superar 50 nudos&quot;)&#10;    private Integer windSpeedKnots;&#10;&#10;    @Min(value = 30, message = &quot;La duración mínima es 30 minutos&quot;)&#10;    @Max(value = 180, message = &quot;La duración máxima es 180 minutos&quot;)&#10;    private Integer classDurationMinutes;&#10;&#10;    @Min(value = 1, message = &quot;El nivel mínimo es 1&quot;)&#10;    @Max(value = 4, message = &quot;El nivel máximo es 4&quot;)&#10;    private Integer studentLevel;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/RoutePlanResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Controller/DTO/RoutePlanResponse.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Controller.DTO;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.ManeuverType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.WindDirection;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class RoutePlanResponse {&#10;    private Long id;&#10;    private Long courseId;&#10;    private CourseType courseType;&#10;    private WindDirection windDirection;&#10;    private Integer windSpeedKnots;&#10;    private Integer classDurationMinutes;&#10;    private Integer studentLevel;&#10;    private List&lt;RouteLegResponse&gt; legs;&#10;    private LocalDateTime createdAt;&#10;    private String summary;&#10;    private String safetyNotes;&#10;    private String imageBase64;&#10;&#10;    @Data&#10;    @Builder&#10;    @AllArgsConstructor&#10;    @NoArgsConstructor&#10;    public static class RouteLegResponse {&#10;        private Integer order;&#10;        private ManeuverType maneuverType;&#10;        private Integer heading;&#10;        private Integer durationMinutes;&#10;        private Integer distanceMeters;&#10;        private String description;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Course.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Course.java" />
              <option name="originalContent" value="package com.empresa.course.MicroserviceCourseApi.Entities;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.util.Date;&#10;&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;courses&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Course {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    private String name;&#10;    private String status;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    private Turno turno;&#10;&#10;    @Column(name = &quot;start_date&quot;)&#10;    private Date startDate;&#10;&#10;    @Column(name = &quot;end_date&quot;)&#10;    private Date endDate;&#10;}&#10;" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;courses&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Course {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private String name;&#10;    &#10;    private String description;&#10;    &#10;    private String status;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    private Turno turno;&#10;&#10;    // Tipo de curso (windsurf, catamaran, etc)&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;course_type&quot;)&#10;    private CourseType courseType;&#10;&#10;    // Duración del curso en minutos&#10;    @Column(name = &quot;duration_minutes&quot;)&#10;    private Integer durationMinutes = 60;&#10;&#10;    // Número máximo de estudiantes&#10;    @Column(name = &quot;max_students&quot;)&#10;    private Integer maxStudents = 10;&#10;&#10;    @Column(name = &quot;start_date&quot;)&#10;    private LocalDate startDate;&#10;&#10;    @Column(name = &quot;end_date&quot;)&#10;    private LocalDate endDate;&#10;&#10;    @Column(name = &quot;start_time&quot;)&#10;    private LocalTime startTime;&#10;&#10;    @Column(name = &quot;end_time&quot;)&#10;    private LocalTime endTime;&#10;&#10;    // IDs de profesores asignados&#10;    @ElementCollection(fetch = FetchType.EAGER)&#10;    @CollectionTable(name = &quot;course_teachers&quot;, joinColumns = @JoinColumn(name = &quot;course_id&quot;))&#10;    @Column(name = &quot;teacher_id&quot;)&#10;    private Set&lt;Long&gt; teacherIds = new HashSet&lt;&gt;();&#10;&#10;    // IDs de estudiantes inscritos&#10;    @ElementCollection(fetch = FetchType.EAGER)&#10;    @CollectionTable(name = &quot;course_students&quot;, joinColumns = @JoinColumn(name = &quot;course_id&quot;))&#10;    @Column(name = &quot;student_id&quot;)&#10;    private Set&lt;Long&gt; studentIds = new HashSet&lt;&gt;();&#10;&#10;    // Horarios del curso&#10;    @OneToMany(mappedBy = &quot;course&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    private List&lt;Schedule&gt; schedules = new ArrayList&lt;&gt;();&#10;&#10;    // Precio del curso&#10;    private Double price;&#10;&#10;    // Si el curso está activo&#10;    private Boolean active = true;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Enums/CourseType.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Enums/CourseType.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities.Enums;&#10;&#10;/**&#10; * Tipos de cursos/actividades disponibles en la escuela de vela&#10; */&#10;public enum CourseType {&#10;    WINDSURF(&quot;Windsurf&quot;, 2, 6),&#10;    CATAMARAN(&quot;Catamarán&quot;, 2, 4),&#10;    MINICATA(&quot;Minicatamarán&quot;, 2, 6),&#10;    OPTIMIST(&quot;Optimist&quot;, 1, 4),&#10;    PADDLE_SURF(&quot;Paddle Surf&quot;, 1, 8),&#10;    KAYAK(&quot;Kayak&quot;, 1, 6),&#10;    SUMMER_CAMP(&quot;Campamento de Verano&quot;, 3, 15),&#10;    VELA_LIGERA(&quot;Vela Ligera&quot;, 2, 4);&#10;&#10;    private final String displayName;&#10;    private final int minInstructors;&#10;    private final int maxStudentsPerInstructor;&#10;&#10;    CourseType(String displayName, int minInstructors, int maxStudentsPerInstructor) {&#10;        this.displayName = displayName;&#10;        this.minInstructors = minInstructors;&#10;        this.maxStudentsPerInstructor = maxStudentsPerInstructor;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    public int getMinInstructors() {&#10;        return minInstructors;&#10;    }&#10;&#10;    public int getMaxStudentsPerInstructor() {&#10;        return maxStudentsPerInstructor;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Enums/ManeuverType.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Enums/ManeuverType.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities.Enums;&#10;&#10;/**&#10; * Tipo de maniobra en navegación&#10; */&#10;public enum ManeuverType {&#10;    VIRADA(&quot;Virada&quot;, &quot;Cambio de bordo pasando la proa por el viento&quot;),&#10;    TRASLUCHADA(&quot;Trasluchada&quot;, &quot;Cambio de bordo pasando la popa por el viento&quot;),&#10;    CEÑIDA(&quot;Ceñida&quot;, &quot;Navegación contra el viento&quot;),&#10;    TRAVES(&quot;Través&quot;, &quot;Navegación perpendicular al viento&quot;),&#10;    LARGO(&quot;Largo&quot;, &quot;Navegación con viento de aleta&quot;),&#10;    POPA(&quot;Popa&quot;, &quot;Navegación con viento de popa&quot;),&#10;    SALIDA(&quot;Salida&quot;, &quot;Salida desde la playa&quot;),&#10;    LLEGADA(&quot;Llegada&quot;, &quot;Llegada a la playa&quot;);&#10;&#10;    private final String displayName;&#10;    private final String description;&#10;&#10;    ManeuverType(String displayName, String description) {&#10;        this.displayName = displayName;&#10;        this.description = description;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Enums/WindDirection.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Enums/WindDirection.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities.Enums;&#10;&#10;/**&#10; * Dirección del viento para planificación de clases&#10; */&#10;public enum WindDirection {&#10;    N(0, &quot;Norte&quot;),&#10;    NE(45, &quot;Noreste&quot;),&#10;    E(90, &quot;Este&quot;),&#10;    SE(135, &quot;Sureste&quot;),&#10;    S(180, &quot;Sur&quot;),&#10;    SW(225, &quot;Suroeste&quot;),&#10;    W(270, &quot;Oeste&quot;),&#10;    NW(315, &quot;Noroeste&quot;);&#10;&#10;    private final int degrees;&#10;    private final String displayName;&#10;&#10;    WindDirection(int degrees, String displayName) {&#10;        this.degrees = degrees;&#10;        this.displayName = displayName;&#10;    }&#10;&#10;    public int getDegrees() {&#10;        return degrees;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    /**&#10;     * Obtiene la dirección del viento a partir de grados&#10;     */&#10;    public static WindDirection fromDegrees(int degrees) {&#10;        degrees = ((degrees % 360) + 360) % 360; // Normalizar a 0-359&#10;        if (degrees &gt;= 337.5 || degrees &lt; 22.5) return N;&#10;        if (degrees &gt;= 22.5 &amp;&amp; degrees &lt; 67.5) return NE;&#10;        if (degrees &gt;= 67.5 &amp;&amp; degrees &lt; 112.5) return E;&#10;        if (degrees &gt;= 112.5 &amp;&amp; degrees &lt; 157.5) return SE;&#10;        if (degrees &gt;= 157.5 &amp;&amp; degrees &lt; 202.5) return S;&#10;        if (degrees &gt;= 202.5 &amp;&amp; degrees &lt; 247.5) return SW;&#10;        if (degrees &gt;= 247.5 &amp;&amp; degrees &lt; 292.5) return W;&#10;        return NW;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/NauticalZone.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/NauticalZone.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * Configuración del canal náutico y zonas de navegación&#10; */&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;nautical_zones&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class NauticalZone {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(nullable = false)&#10;    private String name;&#10;&#10;    private String description;&#10;&#10;    // Tipo de zona: SAFE, RESTRICTED, FORBIDDEN&#10;    @Column(name = &quot;zone_type&quot;)&#10;    private String zoneType;&#10;&#10;    // Nivel mínimo requerido para navegar en esta zona&#10;    @Column(name = &quot;min_level&quot;)&#10;    private Integer minLevel = 1;&#10;&#10;    // Coordenadas del polígono que define la zona (JSON)&#10;    @Column(name = &quot;polygon_coords&quot;, columnDefinition = &quot;TEXT&quot;)&#10;    private String polygonCoords;&#10;&#10;    // Centro de la zona&#10;    @Column(name = &quot;center_lat&quot;)&#10;    private Double centerLatitude;&#10;&#10;    @Column(name = &quot;center_lng&quot;)&#10;    private Double centerLongitude;&#10;&#10;    // Radio en metros (para zonas circulares)&#10;    @Column(name = &quot;radius_meters&quot;)&#10;    private Integer radiusMeters;&#10;&#10;    // Si la zona está activa&#10;    private Boolean active = true;&#10;&#10;    // Notas adicionales&#10;    private String notes;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/RouteLeg.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/RouteLeg.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.ManeuverType;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * Representa un tramo (leg) de una ruta de navegación&#10; */&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;route_legs&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class RouteLeg {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;route_plan_id&quot;)&#10;    private RoutePlan routePlan;&#10;&#10;    // Orden del tramo en la ruta&#10;    @Column(name = &quot;leg_order&quot;)&#10;    private Integer order;&#10;&#10;    // Rumbo en grados&#10;    private Integer heading;&#10;&#10;    // Duración estimada en minutos&#10;    @Column(name = &quot;duration_minutes&quot;)&#10;    private Integer durationMinutes;&#10;&#10;    // Distancia estimada en metros&#10;    @Column(name = &quot;distance_meters&quot;)&#10;    private Integer distanceMeters;&#10;&#10;    // Tipo de maniobra&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;maneuver_type&quot;)&#10;    private ManeuverType maneuverType;&#10;&#10;    // Punto de inicio (latitud)&#10;    @Column(name = &quot;start_lat&quot;)&#10;    private Double startLatitude;&#10;&#10;    // Punto de inicio (longitud)&#10;    @Column(name = &quot;start_lng&quot;)&#10;    private Double startLongitude;&#10;&#10;    // Punto final (latitud)&#10;    @Column(name = &quot;end_lat&quot;)&#10;    private Double endLatitude;&#10;&#10;    // Punto final (longitud)&#10;    @Column(name = &quot;end_lng&quot;)&#10;    private Double endLongitude;&#10;&#10;    // Descripción del tramo&#10;    private String description;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/RoutePlan.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/RoutePlan.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.WindDirection;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Plan de ruta de navegación generado para una clase&#10; */&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;route_plans&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class RoutePlan {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    // Referencia al curso&#10;    @Column(name = &quot;course_id&quot;)&#10;    private Long courseId;&#10;&#10;    // Tipo de clase&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;course_type&quot;)&#10;    private CourseType courseType;&#10;&#10;    // Dirección del viento&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;wind_direction&quot;)&#10;    private WindDirection windDirection;&#10;&#10;    // Velocidad del viento en nudos&#10;    @Column(name = &quot;wind_speed_knots&quot;)&#10;    private Integer windSpeedKnots;&#10;&#10;    // Duración total de la clase en minutos&#10;    @Column(name = &quot;class_duration_minutes&quot;)&#10;    private Integer classDurationMinutes;&#10;&#10;    // Nivel del estudiante (1-4)&#10;    @Column(name = &quot;student_level&quot;)&#10;    private Integer studentLevel;&#10;&#10;    // Posición de la playa&#10;    @Column(name = &quot;beach_latitude&quot;)&#10;    private Double beachLatitude;&#10;&#10;    @Column(name = &quot;beach_longitude&quot;)&#10;    private Double beachLongitude;&#10;&#10;    // Orientación de la playa en grados&#10;    @Column(name = &quot;beach_orientation&quot;)&#10;    private Integer beachOrientation;&#10;&#10;    // Tramos de la ruta&#10;    @OneToMany(mappedBy = &quot;routePlan&quot;, cascade = CascadeType.ALL, orphanRemoval = true)&#10;    @OrderBy(&quot;order ASC&quot;)&#10;    private List&lt;RouteLeg&gt; legs = new ArrayList&lt;&gt;();&#10;&#10;    // Fecha de creación&#10;    @Column(name = &quot;created_at&quot;)&#10;    private LocalDateTime createdAt;&#10;&#10;    // Ruta de la imagen generada&#10;    @Column(name = &quot;image_path&quot;)&#10;    private String imagePath;&#10;&#10;    // Imagen en Base64 (para envío directo)&#10;    @Column(name = &quot;image_base64&quot;, columnDefinition = &quot;TEXT&quot;)&#10;    private String imageBase64;&#10;&#10;    // Resumen textual del plan&#10;    @Column(length = 2000)&#10;    private String summary;&#10;&#10;    // Notas de seguridad&#10;    @Column(name = &quot;safety_notes&quot;, length = 1000)&#10;    private String safetyNotes;&#10;&#10;    @PrePersist&#10;    protected void onCreate() {&#10;        createdAt = LocalDateTime.now();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Schedule.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Entities/Schedule.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Entities;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.DayOfWeek;&#10;import java.time.LocalTime;&#10;&#10;/**&#10; * Representa un horario de clase dentro de un curso&#10; */&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;schedules&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Schedule {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @ManyToOne(fetch = FetchType.LAZY)&#10;    @JoinColumn(name = &quot;course_id&quot;)&#10;    private Course course;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;day_of_week&quot;)&#10;    private DayOfWeek dayOfWeek;&#10;&#10;    @Column(name = &quot;start_time&quot;)&#10;    private LocalTime startTime;&#10;&#10;    @Column(name = &quot;end_time&quot;)&#10;    private LocalTime endTime;&#10;&#10;    // Profesor asignado a este horario específico&#10;    @Column(name = &quot;teacher_id&quot;)&#10;    private Long teacherId;&#10;&#10;    // Si la clase está confirmada&#10;    private Boolean confirmed = false;&#10;&#10;    // Notas adicionales&#10;    private String notes;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Exception/GlobalExceptionHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Exception/GlobalExceptionHandler.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Exception;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.AccessDeniedException;&#10;import org.springframework.validation.FieldError;&#10;import org.springframework.web.bind.MethodArgumentNotValidException;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice&#10;public class GlobalExceptionHandler {&#10;&#10;    @ExceptionHandler(RuntimeException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleRuntimeException(RuntimeException ex) {&#10;        log.error(&quot;Error de runtime: {}&quot;, ex.getMessage());&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.BAD_REQUEST.value(),&#10;                ex.getMessage(),&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.badRequest().body(error);&#10;    }&#10;&#10;    @ExceptionHandler(MethodArgumentNotValidException.class)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        ex.getBindingResult().getAllErrors().forEach(error -&gt; {&#10;            String fieldName = ((FieldError) error).getField();&#10;            String errorMessage = error.getDefaultMessage();&#10;            errors.put(fieldName, errorMessage);&#10;        });&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;status&quot;, HttpStatus.BAD_REQUEST.value());&#10;        response.put(&quot;errors&quot;, errors);&#10;        response.put(&quot;timestamp&quot;, LocalDateTime.now());&#10;        &#10;        return ResponseEntity.badRequest().body(response);&#10;    }&#10;&#10;    @ExceptionHandler(AccessDeniedException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleAccessDenied(AccessDeniedException ex) {&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.FORBIDDEN.value(),&#10;                &quot;Acceso denegado&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception ex) {&#10;        log.error(&quot;Error inesperado: {}&quot;, ex.getMessage(), ex);&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.INTERNAL_SERVER_ERROR.value(),&#10;                &quot;Error interno del servidor&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);&#10;    }&#10;&#10;    public record ErrorResponse(int status, String message, LocalDateTime timestamp) {}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Config/KafkaTopicConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Config/KafkaTopicConfig.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Config;&#10;&#10;import org.apache.kafka.clients.admin.NewTopic;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.kafka.config.TopicBuilder;&#10;&#10;/**&#10; * Configuración de topics de Kafka&#10; */&#10;@Configuration&#10;public class KafkaTopicConfig {&#10;&#10;    public static final String COURSE_EVENTS_TOPIC = &quot;course-events&quot;;&#10;    public static final String TEACHER_EVENTS_TOPIC = &quot;teacher-events&quot;;&#10;    public static final String STUDENT_EVENTS_TOPIC = &quot;student-events&quot;;&#10;    public static final String SCHEDULE_EVENTS_TOPIC = &quot;schedule-events&quot;;&#10;    public static final String NOTIFICATION_EVENTS_TOPIC = &quot;notification-events&quot;;&#10;&#10;    @Bean&#10;    public NewTopic courseEventsTopic() {&#10;        return TopicBuilder.name(COURSE_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;&#10;    @Bean&#10;    public NewTopic teacherEventsTopic() {&#10;        return TopicBuilder.name(TEACHER_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;&#10;    @Bean&#10;    public NewTopic studentEventsTopic() {&#10;        return TopicBuilder.name(STUDENT_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;&#10;    @Bean&#10;    public NewTopic scheduleEventsTopic() {&#10;        return TopicBuilder.name(SCHEDULE_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;&#10;    @Bean&#10;    public NewTopic notificationEventsTopic() {&#10;        return TopicBuilder.name(NOTIFICATION_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Consumer/CourseEventConsumer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Consumer/CourseEventConsumer.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Consumer;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Config.KafkaTopicConfig;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Events.ScheduleEvent;&#10;import com.empresa.course.MicroserviceCourseApi.Service.Inter.ScheduleService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.annotation.KafkaListener;&#10;import org.springframework.stereotype.Service;&#10;&#10;/**&#10; * Consumidor de eventos Kafka para el microservicio de cursos&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class CourseEventConsumer {&#10;&#10;    private final ScheduleService scheduleService;&#10;&#10;    /**&#10;     * Escucha eventos de confirmación de horario de profesores&#10;     */&#10;    @KafkaListener(&#10;        topics = KafkaTopicConfig.SCHEDULE_EVENTS_TOPIC,&#10;        groupId = &quot;course-group&quot;,&#10;        containerFactory = &quot;kafkaListenerContainerFactory&quot;&#10;    )&#10;    public void consumeScheduleEvent(ScheduleEvent event) {&#10;        log.info(&quot;Evento de horario recibido: {} para profesor: {}&quot;, &#10;            event.getEventType(), event.getTeacherId());&#10;        &#10;        try {&#10;            switch (event.getEventType()) {&#10;                case &quot;CONFIRMATION_RECEIVED&quot;:&#10;                    handleConfirmation(event);&#10;                    break;&#10;                case &quot;TEACHER_UNAVAILABLE&quot;:&#10;                    handleTeacherUnavailable(event);&#10;                    break;&#10;                default:&#10;                    log.debug(&quot;Tipo de evento no manejado: {}&quot;, event.getEventType());&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error procesando evento de horario: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private void handleConfirmation(ScheduleEvent event) {&#10;        if (event.getConfirmed()) {&#10;            log.info(&quot;Profesor {} ha confirmado disponibilidad&quot;, event.getTeacherId());&#10;            scheduleService.confirmTeacherSchedule(event.getTeacherId(), true);&#10;        } else {&#10;            log.info(&quot;Profesor {} ha rechazado - Motivo: {}&quot;, &#10;                event.getTeacherId(), event.getRejectionReason());&#10;            scheduleService.handleTeacherRejection(event.getTeacherId(), event.getRejectionReason());&#10;        }&#10;    }&#10;&#10;    private void handleTeacherUnavailable(ScheduleEvent event) {&#10;        log.info(&quot;Profesor {} no disponible, reasignando...&quot;, event.getTeacherId());&#10;        scheduleService.reassignTeacher(event.getScheduleId(), event.getTeacherId());&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/BaseEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/BaseEvent.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Events;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Evento base para todos los eventos Kafka&#10; */&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class BaseEvent implements Serializable {&#10;    private String eventId;&#10;    private String eventType;&#10;    private LocalDateTime timestamp;&#10;    private String source;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/CourseEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/CourseEvent.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Events;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Evento de curso creado/actualizado&#10; */&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class CourseEvent implements Serializable {&#10;    private String eventId;&#10;    private String eventType; // CREATED, UPDATED, DELETED, TEACHER_ASSIGNED, STUDENT_ENROLLED&#10;    private LocalDateTime timestamp;&#10;    &#10;    private Long courseId;&#10;    private String courseName;&#10;    private String courseType;&#10;    private Long teacherId;&#10;    private Long studentId;&#10;    private String status;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/NotificationEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/NotificationEvent.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Events;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Evento de notificación&#10; */&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class NotificationEvent implements Serializable {&#10;    private String eventId;&#10;    private String eventType; // EMAIL, SMS, PUSH&#10;    private LocalDateTime timestamp;&#10;    &#10;    private String recipientEmail;&#10;    private String recipientPhone;&#10;    private String recipientName;&#10;    &#10;    private String subject;&#10;    private String message;&#10;    private String templateName;&#10;    &#10;    // Datos adicionales para la plantilla&#10;    private String templateData;&#10;    &#10;    // Prioridad: HIGH, MEDIUM, LOW&#10;    private String priority;&#10;    &#10;    // Si incluye adjuntos&#10;    private Boolean hasAttachment;&#10;    private String attachmentBase64;&#10;    private String attachmentName;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/ScheduleEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Events/ScheduleEvent.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Events;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;/**&#10; * Evento de horario/planificación&#10; */&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class ScheduleEvent implements Serializable {&#10;    private String eventId;&#10;    private String eventType; // SCHEDULE_CREATED, SCHEDULE_UPDATED, CONFIRMATION_REQUESTED, CONFIRMATION_RECEIVED&#10;    private LocalDateTime timestamp;&#10;    &#10;    private Long scheduleId;&#10;    private Long courseId;&#10;    private Long teacherId;&#10;    private String teacherEmail;&#10;    private String teacherName;&#10;    &#10;    // Lista de horarios asignados&#10;    private List&lt;ScheduleInfo&gt; schedules;&#10;    &#10;    // Si es una solicitud de confirmación&#10;    private Boolean confirmationRequired;&#10;    private LocalDateTime confirmationDeadline;&#10;    &#10;    // Respuesta de confirmación&#10;    private Boolean confirmed;&#10;    private String rejectionReason;&#10;    &#10;    @Data&#10;    @Builder&#10;    @AllArgsConstructor&#10;    @NoArgsConstructor&#10;    public static class ScheduleInfo implements Serializable {&#10;        private String dayOfWeek;&#10;        private String startTime;&#10;        private String endTime;&#10;        private String courseName;&#10;        private String courseType;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Producer/CourseEventProducer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Kafka/Producer/CourseEventProducer.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Kafka.Producer;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Config.KafkaTopicConfig;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Events.CourseEvent;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Events.NotificationEvent;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Events.ScheduleEvent;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.kafka.support.SendResult;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.UUID;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;/**&#10; * Productor de eventos Kafka para el microservicio de cursos&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class CourseEventProducer {&#10;&#10;    private final KafkaTemplate&lt;String, Object&gt; kafkaTemplate;&#10;&#10;    /**&#10;     * Publica un evento de curso&#10;     */&#10;    public void publishCourseEvent(CourseEvent event) {&#10;        if (event.getEventId() == null) {&#10;            event.setEventId(UUID.randomUUID().toString());&#10;        }&#10;        &#10;        CompletableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = &#10;            kafkaTemplate.send(KafkaTopicConfig.COURSE_EVENTS_TOPIC, event.getCourseId().toString(), event);&#10;        &#10;        future.whenComplete((result, ex) -&gt; {&#10;            if (ex == null) {&#10;                log.info(&quot;Evento de curso enviado: {} - Offset: {}&quot;, &#10;                    event.getEventType(), result.getRecordMetadata().offset());&#10;            } else {&#10;                log.error(&quot;Error al enviar evento de curso: {}&quot;, ex.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Publica un evento de horario&#10;     */&#10;    public void publishScheduleEvent(ScheduleEvent event) {&#10;        if (event.getEventId() == null) {&#10;            event.setEventId(UUID.randomUUID().toString());&#10;        }&#10;        &#10;        String key = event.getTeacherId() != null ? event.getTeacherId().toString() : UUID.randomUUID().toString();&#10;        &#10;        CompletableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = &#10;            kafkaTemplate.send(KafkaTopicConfig.SCHEDULE_EVENTS_TOPIC, key, event);&#10;        &#10;        future.whenComplete((result, ex) -&gt; {&#10;            if (ex == null) {&#10;                log.info(&quot;Evento de horario enviado: {} - Offset: {}&quot;, &#10;                    event.getEventType(), result.getRecordMetadata().offset());&#10;            } else {&#10;                log.error(&quot;Error al enviar evento de horario: {}&quot;, ex.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Publica un evento de notificación&#10;     */&#10;    public void publishNotificationEvent(NotificationEvent event) {&#10;        if (event.getEventId() == null) {&#10;            event.setEventId(UUID.randomUUID().toString());&#10;        }&#10;        &#10;        CompletableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = &#10;            kafkaTemplate.send(KafkaTopicConfig.NOTIFICATION_EVENTS_TOPIC, event.getRecipientEmail(), event);&#10;        &#10;        future.whenComplete((result, ex) -&gt; {&#10;            if (ex == null) {&#10;                log.info(&quot;Evento de notificación enviado a: {} - Offset: {}&quot;, &#10;                    event.getRecipientEmail(), result.getRecordMetadata().offset());&#10;            } else {&#10;                log.error(&quot;Error al enviar evento de notificación: {}&quot;, ex.getMessage());&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/CourseRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/CourseRepository.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Repository;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Course;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Turno;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface CourseRepository extends JpaRepository&lt;Course, Long&gt; {&#10;    &#10;    // Buscar por tipo de curso&#10;    List&lt;Course&gt; findByCourseType(CourseType courseType);&#10;    &#10;    // Buscar por turno&#10;    List&lt;Course&gt; findByTurno(Turno turno);&#10;    &#10;    // Buscar cursos activos&#10;    List&lt;Course&gt; findByActiveTrue();&#10;    &#10;    // Buscar cursos por rango de fechas&#10;    List&lt;Course&gt; findByStartDateBetween(LocalDate start, LocalDate end);&#10;    &#10;    // Buscar cursos que empiezan hoy o después&#10;    List&lt;Course&gt; findByStartDateGreaterThanEqual(LocalDate date);&#10;    &#10;    // Buscar cursos con profesor asignado&#10;    @Query(&quot;SELECT c FROM Course c WHERE :teacherId MEMBER OF c.teacherIds&quot;)&#10;    List&lt;Course&gt; findByTeacherId(@Param(&quot;teacherId&quot;) Long teacherId);&#10;    &#10;    // Buscar cursos con estudiante inscrito&#10;    @Query(&quot;SELECT c FROM Course c WHERE :studentId MEMBER OF c.studentIds&quot;)&#10;    List&lt;Course&gt; findByStudentId(@Param(&quot;studentId&quot;) Long studentId);&#10;    &#10;    // Buscar cursos activos por tipo y turno&#10;    List&lt;Course&gt; findByCourseTypeAndTurnoAndActiveTrue(CourseType courseType, Turno turno);&#10;    &#10;    // Contar estudiantes en un curso&#10;    @Query(&quot;SELECT SIZE(c.studentIds) FROM Course c WHERE c.id = :courseId&quot;)&#10;    Integer countStudentsByCourseId(@Param(&quot;courseId&quot;) Long courseId);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/NauticalZoneRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/NauticalZoneRepository.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Repository;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.NauticalZone;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface NauticalZoneRepository extends JpaRepository&lt;NauticalZone, Long&gt; {&#10;    &#10;    List&lt;NauticalZone&gt; findByActiveTrue();&#10;    &#10;    List&lt;NauticalZone&gt; findByZoneType(String zoneType);&#10;    &#10;    List&lt;NauticalZone&gt; findByMinLevelLessThanEqual(Integer level);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/RoutePlanRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/RoutePlanRepository.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Repository;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.RoutePlan;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface RoutePlanRepository extends JpaRepository&lt;RoutePlan, Long&gt; {&#10;    &#10;    List&lt;RoutePlan&gt; findByCourseId(Long courseId);&#10;    &#10;    List&lt;RoutePlan&gt; findByCourseType(CourseType courseType);&#10;    &#10;    List&lt;RoutePlan&gt; findByCreatedAtAfter(LocalDateTime dateTime);&#10;    &#10;    // Últimos planes generados&#10;    List&lt;RoutePlan&gt; findTop10ByOrderByCreatedAtDesc();&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/ScheduleRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Repository/ScheduleRepository.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Repository;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Schedule;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.time.DayOfWeek;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface ScheduleRepository extends JpaRepository&lt;Schedule, Long&gt; {&#10;    &#10;    List&lt;Schedule&gt; findByCourseId(Long courseId);&#10;    &#10;    List&lt;Schedule&gt; findByTeacherId(Long teacherId);&#10;    &#10;    List&lt;Schedule&gt; findByDayOfWeek(DayOfWeek dayOfWeek);&#10;    &#10;    List&lt;Schedule&gt; findByTeacherIdAndConfirmedFalse(Long teacherId);&#10;    &#10;    List&lt;Schedule&gt; findByConfirmedFalse();&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Security/JwtAuthenticationFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Security/JwtAuthenticationFilter.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Security;&#10;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.lang.NonNull;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import java.io.IOException;&#10;import java.util.List;&#10;&#10;/**&#10; * Filtro de autenticación JWT para validar tokens&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;public class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;&#10;    private final JwtService jwtService;&#10;&#10;    @Override&#10;    protected void doFilterInternal(&#10;            @NonNull HttpServletRequest request,&#10;            @NonNull HttpServletResponse response,&#10;            @NonNull FilterChain filterChain&#10;    ) throws ServletException, IOException {&#10;        &#10;        final String authHeader = request.getHeader(&quot;Authorization&quot;);&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            filterChain.doFilter(request, response);&#10;            return;&#10;        }&#10;&#10;        final String jwt = authHeader.substring(7);&#10;        &#10;        try {&#10;            if (jwtService.isTokenValid(jwt) &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {&#10;                String username = jwtService.extractUsername(jwt);&#10;                String role = jwtService.extractRole(jwt);&#10;&#10;                var authorities = List.of(new SimpleGrantedAuthority(&quot;ROLE_&quot; + (role != null ? role : &quot;USER&quot;)));&#10;&#10;                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(&#10;                        username,&#10;                        null,&#10;                        authorities&#10;                );&#10;                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));&#10;                SecurityContextHolder.getContext().setAuthentication(authToken);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error validando token JWT: &quot; + e.getMessage());&#10;        }&#10;&#10;        filterChain.doFilter(request, response);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Security/JwtService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Security/JwtService.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Security;&#10;&#10;import io.jsonwebtoken.Claims;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.io.Decoders;&#10;import io.jsonwebtoken.security.Keys;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * Servicio para validación de tokens JWT&#10; */&#10;@Service&#10;public class JwtService {&#10;&#10;    @Value(&quot;${jwt.secret}&quot;)&#10;    private String secretKey;&#10;&#10;    public String extractUsername(String token) {&#10;        return extractClaim(token, Claims::getSubject);&#10;    }&#10;&#10;    public String extractRole(String token) {&#10;        Claims claims = extractAllClaims(token);&#10;        return claims.get(&quot;role&quot;, String.class);&#10;    }&#10;&#10;    public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {&#10;        final Claims claims = extractAllClaims(token);&#10;        return claimsResolver.apply(claims);&#10;    }&#10;&#10;    public boolean isTokenValid(String token) {&#10;        try {&#10;            return !isTokenExpired(token);&#10;        } catch (Exception e) {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private boolean isTokenExpired(String token) {&#10;        return extractExpiration(token).before(new Date());&#10;    }&#10;&#10;    private Date extractExpiration(String token) {&#10;        return extractClaim(token, Claims::getExpiration);&#10;    }&#10;&#10;    private Claims extractAllClaims(String token) {&#10;        return Jwts.parser()&#10;                .verifyWith(getSignInKey())&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;    }&#10;&#10;    private SecretKey getSignInKey() {&#10;        byte[] keyBytes = Decoders.BASE64.decode(secretKey);&#10;        return Keys.hmacShaKeyFor(keyBytes);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Security/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Security/SecurityConfig.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Security;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.List;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableMethodSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final JwtAuthenticationFilter jwtAuthFilter;&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .csrf(AbstractHttpConfigurer::disable)&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .requestMatchers(&quot;/actuator/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()&#10;                .anyRequest().authenticated()&#10;            )&#10;            .sessionManagement(session -&gt; session&#10;                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;            )&#10;            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);&#10;&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(List.of(&quot;*&quot;));&#10;        configuration.setAllowedMethods(List.of(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;, &quot;OPTIONS&quot;));&#10;        configuration.setAllowedHeaders(List.of(&quot;*&quot;));&#10;        configuration.setExposedHeaders(List.of(&quot;Authorization&quot;));&#10;        &#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/CourseService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/CourseService.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Service.Impl;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Controller.DTO.CourseRequest;&#10;import com.empresa.course.MicroserviceCourseApi.Controller.DTO.CourseResponse;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Course;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Turno;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Events.CourseEvent;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Producer.CourseEventProducer;&#10;import com.empresa.course.MicroserviceCourseApi.Repository.CourseRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class CourseService {&#10;&#10;    private final CourseRepository courseRepository;&#10;    private final CourseEventProducer eventProducer;&#10;&#10;    public List&lt;CourseResponse&gt; findAll() {&#10;        return courseRepository.findAll().stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public CourseResponse findById(Long id) {&#10;        Course course = courseRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + id));&#10;        return toResponse(course);&#10;    }&#10;&#10;    @Transactional&#10;    public CourseResponse create(CourseRequest request) {&#10;        Course course = Course.builder()&#10;                .name(request.getName())&#10;                .description(request.getDescription())&#10;                .status(&quot;ACTIVE&quot;)&#10;                .turno(request.getTurno())&#10;                .courseType(request.getCourseType())&#10;                .durationMinutes(request.getDurationMinutes() != null ? request.getDurationMinutes() : 60)&#10;                .maxStudents(request.getMaxStudents() != null ? request.getMaxStudents() : 10)&#10;                .startDate(request.getStartDate())&#10;                .endDate(request.getEndDate())&#10;                .startTime(request.getStartTime())&#10;                .endTime(request.getEndTime())&#10;                .teacherIds(request.getTeacherIds() != null ? request.getTeacherIds() : new HashSet&lt;&gt;())&#10;                .studentIds(request.getStudentIds() != null ? request.getStudentIds() : new HashSet&lt;&gt;())&#10;                .price(request.getPrice())&#10;                .active(true)&#10;                .build();&#10;&#10;        course = courseRepository.save(course);&#10;&#10;        // Publicar evento&#10;        publishCourseEvent(course, &quot;CREATED&quot;);&#10;&#10;        return toResponse(course);&#10;    }&#10;&#10;    @Transactional&#10;    public CourseResponse update(Long id, CourseRequest request) {&#10;        Course course = courseRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + id));&#10;&#10;        course.setName(request.getName());&#10;        course.setDescription(request.getDescription());&#10;        course.setTurno(request.getTurno());&#10;        course.setCourseType(request.getCourseType());&#10;        if (request.getDurationMinutes() != null) {&#10;            course.setDurationMinutes(request.getDurationMinutes());&#10;        }&#10;        if (request.getMaxStudents() != null) {&#10;            course.setMaxStudents(request.getMaxStudents());&#10;        }&#10;        course.setStartDate(request.getStartDate());&#10;        course.setEndDate(request.getEndDate());&#10;        course.setStartTime(request.getStartTime());&#10;        course.setEndTime(request.getEndTime());&#10;        course.setPrice(request.getPrice());&#10;&#10;        course = courseRepository.save(course);&#10;&#10;        publishCourseEvent(course, &quot;UPDATED&quot;);&#10;&#10;        return toResponse(course);&#10;    }&#10;&#10;    @Transactional&#10;    public void delete(Long id) {&#10;        Course course = courseRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + id));&#10;        &#10;        courseRepository.deleteById(id);&#10;        publishCourseEvent(course, &quot;DELETED&quot;);&#10;    }&#10;&#10;    public List&lt;CourseResponse&gt; findByCourseType(CourseType courseType) {&#10;        return courseRepository.findByCourseType(courseType).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;CourseResponse&gt; findByTurno(Turno turno) {&#10;        return courseRepository.findByTurno(turno).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;CourseResponse&gt; findActive() {&#10;        return courseRepository.findByActiveTrue().stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;CourseResponse&gt; findByTeacherId(Long teacherId) {&#10;        return courseRepository.findByTeacherId(teacherId).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;CourseResponse&gt; findByStudentId(Long studentId) {&#10;        return courseRepository.findByStudentId(studentId).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    @Transactional&#10;    public void assignTeacher(Long courseId, Long teacherId) {&#10;        Course course = courseRepository.findById(courseId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + courseId));&#10;        &#10;        course.getTeacherIds().add(teacherId);&#10;        courseRepository.save(course);&#10;&#10;        CourseEvent event = CourseEvent.builder()&#10;                .eventType(&quot;TEACHER_ASSIGNED&quot;)&#10;                .timestamp(LocalDateTime.now())&#10;                .courseId(courseId)&#10;                .courseName(course.getName())&#10;                .courseType(course.getCourseType().name())&#10;                .teacherId(teacherId)&#10;                .build();&#10;        eventProducer.publishCourseEvent(event);&#10;    }&#10;&#10;    @Transactional&#10;    public void removeTeacher(Long courseId, Long teacherId) {&#10;        Course course = courseRepository.findById(courseId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + courseId));&#10;        &#10;        course.getTeacherIds().remove(teacherId);&#10;        courseRepository.save(course);&#10;    }&#10;&#10;    @Transactional&#10;    public void enrollStudent(Long courseId, Long studentId) {&#10;        Course course = courseRepository.findById(courseId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + courseId));&#10;&#10;        if (course.getMaxStudents() != null &amp;&amp; course.getStudentIds().size() &gt;= course.getMaxStudents()) {&#10;            throw new RuntimeException(&quot;El curso está lleno&quot;);&#10;        }&#10;        &#10;        course.getStudentIds().add(studentId);&#10;        courseRepository.save(course);&#10;&#10;        CourseEvent event = CourseEvent.builder()&#10;                .eventType(&quot;STUDENT_ENROLLED&quot;)&#10;                .timestamp(LocalDateTime.now())&#10;                .courseId(courseId)&#10;                .courseName(course.getName())&#10;                .courseType(course.getCourseType().name())&#10;                .studentId(studentId)&#10;                .build();&#10;        eventProducer.publishCourseEvent(event);&#10;    }&#10;&#10;    @Transactional&#10;    public void unenrollStudent(Long courseId, Long studentId) {&#10;        Course course = courseRepository.findById(courseId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + courseId));&#10;        &#10;        course.getStudentIds().remove(studentId);&#10;        courseRepository.save(course);&#10;    }&#10;&#10;    @Transactional&#10;    public void activateCourse(Long courseId, boolean active) {&#10;        Course course = courseRepository.findById(courseId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Curso no encontrado: &quot; + courseId));&#10;        &#10;        course.setActive(active);&#10;        course.setStatus(active ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);&#10;        courseRepository.save(course);&#10;    }&#10;&#10;    private void publishCourseEvent(Course course, String eventType) {&#10;        CourseEvent event = CourseEvent.builder()&#10;                .eventType(eventType)&#10;                .timestamp(LocalDateTime.now())&#10;                .courseId(course.getId())&#10;                .courseName(course.getName())&#10;                .courseType(course.getCourseType() != null ? course.getCourseType().name() : null)&#10;                .status(course.getStatus())&#10;                .build();&#10;        eventProducer.publishCourseEvent(event);&#10;    }&#10;&#10;    private CourseResponse toResponse(Course course) {&#10;        return CourseResponse.builder()&#10;                .id(course.getId())&#10;                .name(course.getName())&#10;                .description(course.getDescription())&#10;                .status(course.getStatus())&#10;                .turno(course.getTurno())&#10;                .courseType(course.getCourseType())&#10;                .durationMinutes(course.getDurationMinutes())&#10;                .maxStudents(course.getMaxStudents())&#10;                .startDate(course.getStartDate())&#10;                .endDate(course.getEndDate())&#10;                .startTime(course.getStartTime())&#10;                .endTime(course.getEndTime())&#10;                .teacherIds(course.getTeacherIds())&#10;                .studentIds(course.getStudentIds())&#10;                .price(course.getPrice())&#10;                .active(course.getActive())&#10;                .currentStudents(course.getStudentIds() != null ? course.getStudentIds().size() : 0)&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/RouteImageGeneratorService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/RouteImageGeneratorService.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Service.Impl;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.ManeuverType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.RouteLeg;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.RoutePlan;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;import javax.imageio.ImageIO;&#10;import java.awt.*;&#10;import java.awt.geom.AffineTransform;&#10;import java.awt.geom.Path2D;&#10;import java.awt.image.BufferedImage;&#10;import java.io.ByteArrayOutputStream;&#10;import java.util.Base64;&#10;import java.util.List;&#10;&#10;/**&#10; * Servicio para generar imágenes de las rutas de navegación.&#10; * Genera un diagrama visual con:&#10; * - La playa&#10; * - El canal náutico&#10; * - La ruta con todos los tramos&#10; * - Indicadores de viradas y bordos&#10; * - Dirección del viento&#10; */&#10;@Slf4j&#10;@Service&#10;public class RouteImageGeneratorService {&#10;&#10;    private static final int IMAGE_WIDTH = 800;&#10;    private static final int IMAGE_HEIGHT = 600;&#10;    private static final int MARGIN = 50;&#10;&#10;    @Value(&quot;${sailing.beach.name:La Antilla}&quot;)&#10;    private String beachName;&#10;&#10;    /**&#10;     * Genera una imagen de la ruta en formato Base64.&#10;     */&#10;    public String generateRouteImage(RoutePlan plan) {&#10;        try {&#10;            BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_ARGB);&#10;            Graphics2D g2d = image.createGraphics();&#10;&#10;            // Configurar renderizado de alta calidad&#10;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;&#10;            // Fondo (mar)&#10;            drawBackground(g2d);&#10;&#10;            // Playa&#10;            drawBeach(g2d);&#10;&#10;            // Dirección del viento&#10;            drawWindIndicator(g2d, plan.getWindDirection().getDegrees(), plan.getWindSpeedKnots());&#10;&#10;            // Ruta de navegación&#10;            drawRoute(g2d, plan.getLegs(), plan.getBeachLatitude(), plan.getBeachLongitude());&#10;&#10;            // Leyenda&#10;            drawLegend(g2d, plan);&#10;&#10;            // Título&#10;            drawTitle(g2d, plan);&#10;&#10;            g2d.dispose();&#10;&#10;            // Convertir a Base64&#10;            ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;            ImageIO.write(image, &quot;PNG&quot;, baos);&#10;            return Base64.getEncoder().encodeToString(baos.toByteArray());&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando imagen de ruta: {}&quot;, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Error generando imagen de ruta&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void drawBackground(Graphics2D g2d) {&#10;        // Gradiente de mar&#10;        GradientPaint seaGradient = new GradientPaint(&#10;                0, 0, new Color(0, 105, 148),&#10;                0, IMAGE_HEIGHT, new Color(0, 150, 199)&#10;        );&#10;        g2d.setPaint(seaGradient);&#10;        g2d.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);&#10;&#10;        // Patrón de olas sutiles&#10;        g2d.setColor(new Color(255, 255, 255, 30));&#10;        for (int y = 50; y &lt; IMAGE_HEIGHT; y += 40) {&#10;            for (int x = 0; x &lt; IMAGE_WIDTH; x += 80) {&#10;                g2d.drawArc(x, y, 80, 20, 0, 180);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void drawBeach(Graphics2D g2d) {&#10;        // Arena de la playa en la parte inferior&#10;        int beachHeight = 80;&#10;        GradientPaint sandGradient = new GradientPaint(&#10;                0, IMAGE_HEIGHT - beachHeight, new Color(238, 214, 175),&#10;                0, IMAGE_HEIGHT, new Color(210, 180, 140)&#10;        );&#10;        g2d.setPaint(sandGradient);&#10;        g2d.fillRect(0, IMAGE_HEIGHT - beachHeight, IMAGE_WIDTH, beachHeight);&#10;&#10;        // Línea de orilla&#10;        g2d.setColor(new Color(255, 255, 255, 150));&#10;        g2d.setStroke(new BasicStroke(3, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));&#10;        g2d.drawLine(0, IMAGE_HEIGHT - beachHeight, IMAGE_WIDTH, IMAGE_HEIGHT - beachHeight);&#10;&#10;        // Nombre de la playa&#10;        g2d.setColor(new Color(101, 67, 33));&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        g2d.drawString(&quot;️ &quot; + beachName, 20, IMAGE_HEIGHT - 30);&#10;    }&#10;&#10;    private void drawWindIndicator(Graphics2D g2d, int windDegrees, int windSpeed) {&#10;        int centerX = IMAGE_WIDTH - 80;&#10;        int centerY = 80;&#10;        int arrowLength = 40;&#10;&#10;        // Círculo de fondo&#10;        g2d.setColor(new Color(255, 255, 255, 200));&#10;        g2d.fillOval(centerX - 50, centerY - 50, 100, 100);&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.setStroke(new BasicStroke(2));&#10;        g2d.drawOval(centerX - 50, centerY - 50, 100, 100);&#10;&#10;        // Flecha de viento&#10;        AffineTransform old = g2d.getTransform();&#10;        g2d.translate(centerX, centerY);&#10;        g2d.rotate(Math.toRadians(windDegrees));&#10;&#10;        // Cuerpo de la flecha&#10;        g2d.setColor(new Color(220, 50, 50));&#10;        g2d.setStroke(new BasicStroke(4, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));&#10;        g2d.drawLine(0, -arrowLength, 0, arrowLength);&#10;&#10;        // Punta de la flecha (hacia donde va el viento)&#10;        Path2D arrow = new Path2D.Double();&#10;        arrow.moveTo(0, arrowLength);&#10;        arrow.lineTo(-10, arrowLength - 15);&#10;        arrow.lineTo(10, arrowLength - 15);&#10;        arrow.closePath();&#10;        g2d.fill(arrow);&#10;&#10;        g2d.setTransform(old);&#10;&#10;        // Texto de velocidad&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        String windText = windSpeed + &quot; kn&quot;;&#10;        g2d.drawString(windText, centerX - 15, centerY + 70);&#10;        g2d.drawString(&quot;Viento&quot;, centerX - 20, centerY - 55);&#10;    }&#10;&#10;    private void drawRoute(Graphics2D g2d, List&lt;RouteLeg&gt; legs, double beachLat, double beachLng) {&#10;        if (legs.isEmpty()) return;&#10;&#10;        // Calcular escala y offset para centrar la ruta&#10;        double minLat = legs.stream().mapToDouble(RouteLeg::getStartLatitude).min().orElse(beachLat);&#10;        double maxLat = legs.stream().mapToDouble(RouteLeg::getEndLatitude).max().orElse(beachLat);&#10;        double minLng = legs.stream().mapToDouble(RouteLeg::getStartLongitude).min().orElse(beachLng);&#10;        double maxLng = legs.stream().mapToDouble(RouteLeg::getEndLongitude).max().orElse(beachLng);&#10;&#10;        // Añadir margen&#10;        double latRange = Math.max(maxLat - minLat, 0.005);&#10;        double lngRange = Math.max(maxLng - minLng, 0.005);&#10;&#10;        // Área de dibujo&#10;        int drawWidth = IMAGE_WIDTH - 2 * MARGIN - 120; // Espacio para leyenda&#10;        int drawHeight = IMAGE_HEIGHT - 2 * MARGIN - 80; // Espacio para playa&#10;&#10;        // Punto de partida (playa)&#10;        int startX = MARGIN + 50;&#10;        int startY = IMAGE_HEIGHT - MARGIN - 80;&#10;&#10;        // Dibujar cada tramo&#10;        int prevX = startX;&#10;        int prevY = startY;&#10;&#10;        for (int i = 0; i &lt; legs.size(); i++) {&#10;            RouteLeg leg = legs.get(i);&#10;&#10;            // Calcular posiciones en píxeles&#10;            int endX = (int) (startX + ((leg.getEndLongitude() - beachLng) / lngRange) * drawWidth);&#10;            int endY = (int) (startY - ((leg.getEndLatitude() - beachLat) / latRange) * drawHeight);&#10;&#10;            // Limitar al área visible&#10;            endX = Math.max(MARGIN, Math.min(IMAGE_WIDTH - MARGIN - 120, endX));&#10;            endY = Math.max(MARGIN, Math.min(IMAGE_HEIGHT - MARGIN - 80, endY));&#10;&#10;            // Color según tipo de maniobra&#10;            Color legColor = getColorForManeuver(leg.getManeuverType());&#10;            g2d.setColor(legColor);&#10;            g2d.setStroke(new BasicStroke(3, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));&#10;&#10;            // Dibujar línea del tramo&#10;            if (leg.getDistanceMeters() &gt; 0) {&#10;                g2d.drawLine(prevX, prevY, endX, endY);&#10;&#10;                // Dibujar flecha de dirección en el medio&#10;                drawArrowHead(g2d, prevX, prevY, endX, endY, legColor);&#10;&#10;                // Número del tramo&#10;                int midX = (prevX + endX) / 2;&#10;                int midY = (prevY + endY) / 2;&#10;                g2d.setColor(Color.WHITE);&#10;                g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;                g2d.fillOval(midX - 8, midY - 8, 16, 16);&#10;                g2d.setColor(Color.DARK_GRAY);&#10;                g2d.drawString(String.valueOf(leg.getOrder()), midX - 3, midY + 4);&#10;            }&#10;&#10;            // Marcador de virada&#10;            if (leg.getManeuverType() == ManeuverType.VIRADA || &#10;                leg.getManeuverType() == ManeuverType.TRASLUCHADA) {&#10;                drawManeuverMarker(g2d, endX, endY, leg.getManeuverType());&#10;            }&#10;&#10;            prevX = endX;&#10;            prevY = endY;&#10;        }&#10;&#10;        // Punto de inicio (embarcadero)&#10;        g2d.setColor(new Color(0, 150, 0));&#10;        g2d.fillOval(startX - 8, startY - 8, 16, 16);&#10;        g2d.setColor(Color.WHITE);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 10));&#10;        g2d.drawString(&quot;S&quot;, startX - 3, startY + 4);&#10;&#10;        // Punto final&#10;        g2d.setColor(new Color(200, 0, 0));&#10;        g2d.fillOval(prevX - 8, prevY - 8, 16, 16);&#10;        g2d.setColor(Color.WHITE);&#10;        g2d.drawString(&quot;F&quot;, prevX - 3, prevY + 4);&#10;    }&#10;&#10;    private void drawArrowHead(Graphics2D g2d, int x1, int y1, int x2, int y2, Color color) {&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        int midX = (x1 + x2) / 2;&#10;        int midY = (y1 + y2) / 2;&#10;        int arrowSize = 8;&#10;&#10;        Path2D arrow = new Path2D.Double();&#10;        arrow.moveTo(midX + arrowSize * Math.cos(angle), midY + arrowSize * Math.sin(angle));&#10;        arrow.lineTo(midX - arrowSize * Math.cos(angle - Math.PI/6), midY - arrowSize * Math.sin(angle - Math.PI/6));&#10;        arrow.lineTo(midX - arrowSize * Math.cos(angle + Math.PI/6), midY - arrowSize * Math.sin(angle + Math.PI/6));&#10;        arrow.closePath();&#10;&#10;        g2d.setColor(color);&#10;        g2d.fill(arrow);&#10;    }&#10;&#10;    private void drawManeuverMarker(Graphics2D g2d, int x, int y, ManeuverType type) {&#10;        g2d.setColor(type == ManeuverType.VIRADA ? new Color(255, 165, 0) : new Color(255, 100, 100));&#10;        g2d.setStroke(new BasicStroke(2));&#10;        &#10;        // Círculo con símbolo&#10;        g2d.drawOval(x - 6, y - 6, 12, 12);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 8));&#10;        g2d.drawString(type == ManeuverType.VIRADA ? &quot;V&quot; : &quot;T&quot;, x - 3, y + 3);&#10;    }&#10;&#10;    private Color getColorForManeuver(ManeuverType type) {&#10;        return switch (type) {&#10;            case CENIDA -&gt; new Color(220, 20, 60); // Rojo - dificultad&#10;            case TRAVES -&gt; new Color(30, 144, 255); // Azul&#10;            case LARGO -&gt; new Color(50, 205, 50); // Verde&#10;            case POPA -&gt; new Color(255, 215, 0); // Dorado&#10;            case SALIDA, LLEGADA -&gt; new Color(128, 0, 128); // Púrpura&#10;            default -&gt; new Color(100, 100, 100);&#10;        };&#10;    }&#10;&#10;    private void drawLegend(Graphics2D g2d, RoutePlan plan) {&#10;        int legendX = IMAGE_WIDTH - 140;&#10;        int legendY = 150;&#10;        int lineHeight = 20;&#10;&#10;        // Fondo de leyenda&#10;        g2d.setColor(new Color(255, 255, 255, 220));&#10;        g2d.fillRoundRect(legendX - 10, legendY - 20, 130, 180, 10, 10);&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.setStroke(new BasicStroke(1));&#10;        g2d.drawRoundRect(legendX - 10, legendY - 20, 130, 180, 10, 10);&#10;&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));&#10;        g2d.drawString(&quot;Leyenda&quot;, legendX, legendY);&#10;&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 10));&#10;        int y = legendY + lineHeight;&#10;&#10;        // Tipos de navegación&#10;        drawLegendItem(g2d, legendX, y, new Color(220, 20, 60), &quot;Ceñida&quot;);&#10;        y += lineHeight;&#10;        drawLegendItem(g2d, legendX, y, new Color(30, 144, 255), &quot;Través&quot;);&#10;        y += lineHeight;&#10;        drawLegendItem(g2d, legendX, y, new Color(50, 205, 50), &quot;Largo&quot;);&#10;        y += lineHeight;&#10;        drawLegendItem(g2d, legendX, y, new Color(255, 215, 0), &quot;Popa&quot;);&#10;        y += lineHeight + 5;&#10;&#10;        // Marcadores&#10;        g2d.setColor(new Color(0, 150, 0));&#10;        g2d.fillOval(legendX, y - 4, 10, 10);&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.drawString(&quot;Salida&quot;, legendX + 15, y + 4);&#10;        y += lineHeight;&#10;&#10;        g2d.setColor(new Color(200, 0, 0));&#10;        g2d.fillOval(legendX, y - 4, 10, 10);&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.drawString(&quot;Llegada&quot;, legendX + 15, y + 4);&#10;        y += lineHeight;&#10;&#10;        g2d.setColor(new Color(255, 165, 0));&#10;        g2d.drawString(&quot;V = Virada&quot;, legendX, y + 4);&#10;        y += lineHeight;&#10;        g2d.drawString(&quot;T = Trasluchada&quot;, legendX, y + 4);&#10;    }&#10;&#10;    private void drawLegendItem(Graphics2D g2d, int x, int y, Color color, String text) {&#10;        g2d.setColor(color);&#10;        g2d.setStroke(new BasicStroke(3));&#10;        g2d.drawLine(x, y, x + 20, y);&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.drawString(text, x + 25, y + 4);&#10;    }&#10;&#10;    private void drawTitle(Graphics2D g2d, RoutePlan plan) {&#10;        // Título&#10;        g2d.setColor(new Color(255, 255, 255, 220));&#10;        g2d.fillRoundRect(10, 10, 350, 60, 10, 10);&#10;&#10;        g2d.setColor(Color.DARK_GRAY);&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 16));&#10;        g2d.drawString(&quot;Plan de Navegación - &quot; + plan.getCourseType().getDisplayName(), 20, 35);&#10;&#10;        g2d.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 12));&#10;        g2d.drawString(String.format(&quot;Duración: %d min | Nivel: %d | %s&quot;,&#10;                plan.getClassDurationMinutes(),&#10;                plan.getStudentLevel(),&#10;                plan.getWindDirection().getDisplayName() + &quot; &quot; + plan.getWindSpeedKnots() + &quot;kn&quot;&#10;        ), 20, 55);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/RoutePlannerService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/RoutePlannerService.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Service.Impl;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.ManeuverType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.WindDirection;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.NauticalZone;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.RouteLeg;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.RoutePlan;&#10;import com.empresa.course.MicroserviceCourseApi.Repository.NauticalZoneRepository;&#10;import com.empresa.course.MicroserviceCourseApi.Repository.RoutePlanRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Servicio de planificación de rutas de navegación.&#10; * Genera planes de ruta basados en:&#10; * - Dirección y velocidad del viento&#10; * - Tipo de embarcación/clase&#10; * - Nivel del estudiante&#10; * - Duración de la clase&#10; * - Configuración de la playa&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class RoutePlannerService {&#10;&#10;    private final RoutePlanRepository routePlanRepository;&#10;    private final NauticalZoneRepository nauticalZoneRepository;&#10;    private final RouteImageGeneratorService imageGenerator;&#10;&#10;    @Value(&quot;${sailing.beach.latitude:37.2074}&quot;)&#10;    private Double beachLatitude;&#10;&#10;    @Value(&quot;${sailing.beach.longitude:-7.2193}&quot;)&#10;    private Double beachLongitude;&#10;&#10;    @Value(&quot;${sailing.beach.orientation:180}&quot;)&#10;    private Integer beachOrientation;&#10;&#10;    // Constantes de navegación&#10;    private static final int ANGLE_CENIDA = 45;  // Ángulo mínimo respecto al viento para ceñir&#10;    private static final int ANGLE_TRAVES = 90;  // Navegación a través&#10;    private static final int ANGLE_LARGO = 135;  // Navegación en largo&#10;    private static final double KNOTS_TO_MS = 0.514444; // Conversión nudos a m/s&#10;&#10;    /**&#10;     * Genera un plan de ruta completo para una clase.&#10;     */&#10;    @Transactional&#10;    public RoutePlan generateRoutePlan(&#10;            Long courseId,&#10;            CourseType courseType,&#10;            WindDirection windDirection,&#10;            int windSpeedKnots,&#10;            int classDurationMinutes,&#10;            int studentLevel) {&#10;&#10;        log.info(&quot;Generando plan de ruta para {} - Viento: {} a {} nudos - Nivel: {}&quot;,&#10;                courseType, windDirection, windSpeedKnots, studentLevel);&#10;&#10;        // Crear plan base&#10;        RoutePlan plan = RoutePlan.builder()&#10;                .courseId(courseId)&#10;                .courseType(courseType)&#10;                .windDirection(windDirection)&#10;                .windSpeedKnots(windSpeedKnots)&#10;                .classDurationMinutes(classDurationMinutes)&#10;                .studentLevel(studentLevel)&#10;                .beachLatitude(beachLatitude)&#10;                .beachLongitude(beachLongitude)&#10;                .beachOrientation(beachOrientation)&#10;                .legs(new ArrayList&lt;&gt;())&#10;                .build();&#10;&#10;        // Obtener zonas navegables según nivel&#10;        List&lt;NauticalZone&gt; allowedZones = nauticalZoneRepository.findByMinLevelLessThanEqual(studentLevel);&#10;&#10;        // Calcular parámetros de navegación según nivel&#10;        NavigationParams params = calculateNavigationParams(studentLevel, windSpeedKnots, courseType);&#10;&#10;        // Generar los tramos de la ruta&#10;        List&lt;RouteLeg&gt; legs = generateLegs(plan, params, windDirection, classDurationMinutes);&#10;        plan.setLegs(legs);&#10;&#10;        // Generar resumen&#10;        plan.setSummary(generateSummary(plan, legs));&#10;&#10;        // Generar notas de seguridad&#10;        plan.setSafetyNotes(generateSafetyNotes(windSpeedKnots, studentLevel, courseType));&#10;&#10;        // Guardar plan&#10;        plan = routePlanRepository.save(plan);&#10;&#10;        // Generar imagen de la ruta&#10;        try {&#10;            String imageBase64 = imageGenerator.generateRouteImage(plan);&#10;            plan.setImageBase64(imageBase64);&#10;            plan = routePlanRepository.save(plan);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error generando imagen de ruta: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        return plan;&#10;    }&#10;&#10;    /**&#10;     * Calcula los parámetros de navegación según el nivel del estudiante.&#10;     */&#10;    private NavigationParams calculateNavigationParams(int studentLevel, int windSpeedKnots, CourseType courseType) {&#10;        NavigationParams params = new NavigationParams();&#10;&#10;        // Distancia máxima desde la playa (metros)&#10;        switch (studentLevel) {&#10;            case 1 -&gt; params.maxDistance = 200;  // Principiante&#10;            case 2 -&gt; params.maxDistance = 400;  // Intermedio&#10;            case 3 -&gt; params.maxDistance = 600;  // Avanzado&#10;            default -&gt; params.maxDistance = 800; // Experto&#10;        }&#10;&#10;        // Velocidad estimada según tipo de embarcación y viento (nudos)&#10;        double baseSpeed = switch (courseType) {&#10;            case WINDSURF -&gt; windSpeedKnots * 0.4;&#10;            case CATAMARAN -&gt; windSpeedKnots * 0.6;&#10;            case MINICATA -&gt; windSpeedKnots * 0.5;&#10;            case OPTIMIST -&gt; windSpeedKnots * 0.3;&#10;            case PADDLE_SURF -&gt; 2.0; // Velocidad fija&#10;            case KAYAK -&gt; 3.0;&#10;            default -&gt; windSpeedKnots * 0.4;&#10;        };&#10;        params.estimatedSpeed = Math.max(2, Math.min(baseSpeed, 12)); // Entre 2 y 12 nudos&#10;&#10;        // Tiempo máximo por bordo según nivel (minutos)&#10;        params.maxLegDuration = switch (studentLevel) {&#10;            case 1 -&gt; 5;&#10;            case 2 -&gt; 8;&#10;            case 3 -&gt; 12;&#10;            default -&gt; 15;&#10;        };&#10;&#10;        // Maniobras permitidas según nivel&#10;        params.canTack = studentLevel &gt;= 1;&#10;        params.canGybe = studentLevel &gt;= 2;&#10;        params.canSailUpwind = studentLevel &gt;= 2;&#10;&#10;        return params;&#10;    }&#10;&#10;    /**&#10;     * Genera los tramos de la ruta.&#10;     */&#10;    private List&lt;RouteLeg&gt; generateLegs(RoutePlan plan, NavigationParams params, &#10;                                         WindDirection windDirection, int totalMinutes) {&#10;        List&lt;RouteLeg&gt; legs = new ArrayList&lt;&gt;();&#10;        int remainingMinutes = totalMinutes;&#10;        int order = 1;&#10;&#10;        double currentLat = beachLatitude;&#10;        double currentLng = beachLongitude;&#10;        int windDegrees = windDirection.getDegrees();&#10;&#10;        // 1. Salida desde la playa&#10;        RouteLeg departure = createLeg(order++, ManeuverType.SALIDA, 3,&#10;                calculateHeadingForDeparture(windDegrees, beachOrientation),&#10;                100, currentLat, currentLng, params.estimatedSpeed);&#10;        legs.add(departure);&#10;        remainingMinutes -= departure.getDurationMinutes();&#10;        currentLat = departure.getEndLatitude();&#10;        currentLng = departure.getEndLongitude();&#10;&#10;        // 2. Navegación principal - alternar rumbos&#10;        boolean goingLeft = true;&#10;        while (remainingMinutes &gt; 10) { // Guardar tiempo para volver&#10;            int legDuration = Math.min(params.maxLegDuration, remainingMinutes / 3);&#10;            &#10;            // Calcular rumbo de navegación&#10;            int heading = calculateSailingHeading(windDegrees, goingLeft, params.canSailUpwind);&#10;            ManeuverType maneuver = determineManeuverType(heading, windDegrees);&#10;&#10;            // Calcular distancia&#10;            double speedMs = params.estimatedSpeed * KNOTS_TO_MS;&#10;            int distanceMeters = (int) (speedMs * legDuration * 60);&#10;&#10;            // Verificar que no nos alejamos demasiado&#10;            if (calculateDistanceFromBeach(currentLat, currentLng) + distanceMeters &gt; params.maxDistance) {&#10;                // Cambiar de bordo&#10;                goingLeft = !goingLeft;&#10;                &#10;                // Añadir virada o trasluchada&#10;                ManeuverType turnType = goingLeft ? ManeuverType.VIRADA : ManeuverType.TRASLUCHADA;&#10;                if (params.canTack || turnType == ManeuverType.VIRADA) {&#10;                    RouteLeg turn = createLeg(order++, turnType, 1, &#10;                            heading, 0, currentLat, currentLng, 0);&#10;                    legs.add(turn);&#10;                    remainingMinutes -= 1;&#10;                }&#10;                continue;&#10;            }&#10;&#10;            // Crear tramo de navegación&#10;            RouteLeg leg = createLeg(order++, maneuver, legDuration, &#10;                    heading, distanceMeters, currentLat, currentLng, params.estimatedSpeed);&#10;            legs.add(leg);&#10;            remainingMinutes -= legDuration;&#10;            currentLat = leg.getEndLatitude();&#10;            currentLng = leg.getEndLongitude();&#10;            goingLeft = !goingLeft;&#10;&#10;            // Añadir virada&#10;            if (remainingMinutes &gt; 10 &amp;&amp; params.canTack) {&#10;                RouteLeg turn = createLeg(order++, ManeuverType.VIRADA, 1,&#10;                        heading, 0, currentLat, currentLng, 0);&#10;                legs.add(turn);&#10;                remainingMinutes -= 1;&#10;            }&#10;        }&#10;&#10;        // 3. Regreso a la playa&#10;        int returnHeading = calculateReturnHeading(currentLat, currentLng, beachLatitude, beachLongitude);&#10;        int returnDistance = (int) calculateDistanceFromBeach(currentLat, currentLng);&#10;        RouteLeg returnLeg = createLeg(order++, ManeuverType.LLEGADA, remainingMinutes - 2,&#10;                returnHeading, returnDistance, currentLat, currentLng, params.estimatedSpeed);&#10;        legs.add(returnLeg);&#10;&#10;        return legs;&#10;    }&#10;&#10;    private RouteLeg createLeg(int order, ManeuverType maneuver, int durationMinutes,&#10;                                int heading, int distanceMeters, double startLat, double startLng,&#10;                                double speedKnots) {&#10;        // Calcular punto final&#10;        double[] endPoint = calculateEndPoint(startLat, startLng, heading, distanceMeters);&#10;&#10;        return RouteLeg.builder()&#10;                .order(order)&#10;                .maneuverType(maneuver)&#10;                .durationMinutes(durationMinutes)&#10;                .heading(heading)&#10;                .distanceMeters(distanceMeters)&#10;                .startLatitude(startLat)&#10;                .startLongitude(startLng)&#10;                .endLatitude(endPoint[0])&#10;                .endLongitude(endPoint[1])&#10;                .description(generateLegDescription(maneuver, heading, durationMinutes))&#10;                .build();&#10;    }&#10;&#10;    private int calculateHeadingForDeparture(int windDegrees, int beachOrientation) {&#10;        // Salir perpendicular a la playa, hacia donde viene el viento&#10;        int optimalHeading = (beachOrientation + 180) % 360;&#10;        // Ajustar para no ir directamente contra el viento&#10;        if (Math.abs(optimalHeading - windDegrees) &lt; ANGLE_CENIDA) {&#10;            optimalHeading = (optimalHeading + ANGLE_CENIDA) % 360;&#10;        }&#10;        return optimalHeading;&#10;    }&#10;&#10;    private int calculateSailingHeading(int windDegrees, boolean goLeft, boolean canSailUpwind) {&#10;        int offset = canSailUpwind ? ANGLE_CENIDA : ANGLE_TRAVES;&#10;        if (goLeft) {&#10;            return (windDegrees + offset) % 360;&#10;        } else {&#10;            return (windDegrees - offset + 360) % 360;&#10;        }&#10;    }&#10;&#10;    private ManeuverType determineManeuverType(int heading, int windDegrees) {&#10;        int angleDiff = Math.abs(heading - windDegrees);&#10;        if (angleDiff &gt; 180) angleDiff = 360 - angleDiff;&#10;&#10;        if (angleDiff &lt;= 60) return ManeuverType.CENIDA;&#10;        if (angleDiff &lt;= 120) return ManeuverType.TRAVES;&#10;        if (angleDiff &lt;= 150) return ManeuverType.LARGO;&#10;        return ManeuverType.POPA;&#10;    }&#10;&#10;    private double calculateDistanceFromBeach(double lat, double lng) {&#10;        // Fórmula simplificada de Haversine&#10;        double dLat = Math.toRadians(lat - beachLatitude);&#10;        double dLng = Math.toRadians(lng - beachLongitude);&#10;        double a = Math.sin(dLat/2) * Math.sin(dLat/2) +&#10;                   Math.cos(Math.toRadians(beachLatitude)) * Math.cos(Math.toRadians(lat)) *&#10;                   Math.sin(dLng/2) * Math.sin(dLng/2);&#10;        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));&#10;        return 6371000 * c; // Radio de la tierra en metros&#10;    }&#10;&#10;    private int calculateReturnHeading(double fromLat, double fromLng, double toLat, double toLng) {&#10;        double dLng = Math.toRadians(toLng - fromLng);&#10;        double y = Math.sin(dLng) * Math.cos(Math.toRadians(toLat));&#10;        double x = Math.cos(Math.toRadians(fromLat)) * Math.sin(Math.toRadians(toLat)) -&#10;                   Math.sin(Math.toRadians(fromLat)) * Math.cos(Math.toRadians(toLat)) * Math.cos(dLng);&#10;        double bearing = Math.atan2(y, x);&#10;        return (int) ((Math.toDegrees(bearing) + 360) % 360);&#10;    }&#10;&#10;    private double[] calculateEndPoint(double lat, double lng, int heading, int distanceMeters) {&#10;        double R = 6371000; // Radio de la tierra en metros&#10;        double d = distanceMeters / R;&#10;        double brng = Math.toRadians(heading);&#10;        double lat1 = Math.toRadians(lat);&#10;        double lng1 = Math.toRadians(lng);&#10;&#10;        double lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) +&#10;                               Math.cos(lat1) * Math.sin(d) * Math.cos(brng));&#10;        double lng2 = lng1 + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(lat1),&#10;                                        Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));&#10;&#10;        return new double[]{Math.toDegrees(lat2), Math.toDegrees(lng2)};&#10;    }&#10;&#10;    private String generateLegDescription(ManeuverType maneuver, int heading, int durationMinutes) {&#10;        String direction = getCompassDirection(heading);&#10;        return String.format(&quot;%s - Rumbo %d° (%s) - %d minutos&quot;,&#10;                maneuver.getDisplayName(), heading, direction, durationMinutes);&#10;    }&#10;&#10;    private String getCompassDirection(int heading) {&#10;        if (heading &gt;= 337.5 || heading &lt; 22.5) return &quot;N&quot;;&#10;        if (heading &gt;= 22.5 &amp;&amp; heading &lt; 67.5) return &quot;NE&quot;;&#10;        if (heading &gt;= 67.5 &amp;&amp; heading &lt; 112.5) return &quot;E&quot;;&#10;        if (heading &gt;= 112.5 &amp;&amp; heading &lt; 157.5) return &quot;SE&quot;;&#10;        if (heading &gt;= 157.5 &amp;&amp; heading &lt; 202.5) return &quot;S&quot;;&#10;        if (heading &gt;= 202.5 &amp;&amp; heading &lt; 247.5) return &quot;SW&quot;;&#10;        if (heading &gt;= 247.5 &amp;&amp; heading &lt; 292.5) return &quot;W&quot;;&#10;        return &quot;NW&quot;;&#10;    }&#10;&#10;    private String generateSummary(RoutePlan plan, List&lt;RouteLeg&gt; legs) {&#10;        int totalDistance = legs.stream().mapToInt(RouteLeg::getDistanceMeters).sum();&#10;        long viradas = legs.stream().filter(l -&gt; l.getManeuverType() == ManeuverType.VIRADA).count();&#10;        long trasluchadas = legs.stream().filter(l -&gt; l.getManeuverType() == ManeuverType.TRASLUCHADA).count();&#10;&#10;        return String.format(&#10;                &quot;Plan de navegación para %s\n&quot; +&#10;                &quot;Viento: %s a %d nudos\n&quot; +&#10;                &quot;Duración: %d minutos\n&quot; +&#10;                &quot;Distancia total: %d metros\n&quot; +&#10;                &quot;Viradas: %d | Trasluchadas: %d\n&quot; +&#10;                &quot;Total tramos: %d&quot;,&#10;                plan.getCourseType().getDisplayName(),&#10;                plan.getWindDirection().getDisplayName(),&#10;                plan.getWindSpeedKnots(),&#10;                plan.getClassDurationMinutes(),&#10;                totalDistance,&#10;                viradas, trasluchadas,&#10;                legs.size()&#10;        );&#10;    }&#10;&#10;    private String generateSafetyNotes(int windSpeedKnots, int studentLevel, CourseType courseType) {&#10;        StringBuilder notes = new StringBuilder();&#10;&#10;        if (windSpeedKnots &gt; 15) {&#10;            notes.append(&quot;⚠️ Viento fuerte - Extremar precauciones\n&quot;);&#10;        }&#10;        if (windSpeedKnots &gt; 20 &amp;&amp; studentLevel &lt; 3) {&#10;            notes.append(&quot;⚠️ Condiciones no recomendadas para este nivel\n&quot;);&#10;        }&#10;        if (studentLevel == 1) {&#10;            notes.append(&quot; Mantener siempre contacto visual con la playa\n&quot;);&#10;            notes.append(&quot; No alejarse más de 200m de la orilla\n&quot;);&#10;        }&#10;&#10;        notes.append(&quot; Llevar siempre chaleco salvavidas\n&quot;);&#10;        notes.append(&quot; Comunicar cualquier problema al instructor\n&quot;);&#10;&#10;        return notes.toString();&#10;    }&#10;&#10;    /**&#10;     * Clase auxiliar para parámetros de navegación&#10;     */&#10;    private static class NavigationParams {&#10;        int maxDistance;&#10;        double estimatedSpeed;&#10;        int maxLegDuration;&#10;        boolean canTack;&#10;        boolean canGybe;&#10;        boolean canSailUpwind;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/ScheduleOrganizerService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/ScheduleOrganizerService.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Service.Impl;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Course;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Enums.CourseType;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Schedule;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Turno;&#10;import com.empresa.course.MicroserviceCourseApi.Repository.CourseRepository;&#10;import com.empresa.course.MicroserviceCourseApi.Repository.ScheduleRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.DayOfWeek;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Servicio para organizar los horarios de clases.&#10; * Implementa un algoritmo que:&#10; * 1. Distribuye las clases a lo largo del día según turno&#10; * 2. Evita solapamientos&#10; * 3. Optimiza el uso de recursos (profesores y material)&#10; * 4. Agrupa clases del mismo tipo cuando es posible&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class ScheduleOrganizerService {&#10;&#10;    private final CourseRepository courseRepository;&#10;    private final ScheduleRepository scheduleRepository;&#10;&#10;    // Horarios por turno&#10;    private static final LocalTime MORNING_START = LocalTime.of(9, 0);&#10;    private static final LocalTime MORNING_END = LocalTime.of(14, 0);&#10;    private static final LocalTime AFTERNOON_START = LocalTime.of(16, 0);&#10;    private static final LocalTime AFTERNOON_END = LocalTime.of(20, 0);&#10;&#10;    // Tiempo mínimo entre clases (minutos)&#10;    private static final int MIN_GAP_BETWEEN_CLASSES = 15;&#10;&#10;    /**&#10;     * Organiza automáticamente los horarios para una semana.&#10;     * &#10;     * @param weekStartDate Fecha de inicio de la semana&#10;     * @return Lista de horarios generados&#10;     */&#10;    @Transactional&#10;    public List&lt;Schedule&gt; organizeWeekSchedule(LocalDate weekStartDate) {&#10;        log.info(&quot;Organizando horarios para la semana del {}&quot;, weekStartDate);&#10;&#10;        List&lt;Schedule&gt; generatedSchedules = new ArrayList&lt;&gt;();&#10;&#10;        // Obtener todos los cursos activos&#10;        List&lt;Course&gt; activeCourses = courseRepository.findByActiveTrue();&#10;&#10;        if (activeCourses.isEmpty()) {&#10;            log.warn(&quot;No hay cursos activos para programar&quot;);&#10;            return generatedSchedules;&#10;        }&#10;&#10;        // Organizar por cada día de la semana (L-V para cursos normales, L-D para summer camp)&#10;        for (int i = 0; i &lt; 7; i++) {&#10;            LocalDate currentDate = weekStartDate.plusDays(i);&#10;            DayOfWeek dayOfWeek = currentDate.getDayOfWeek();&#10;&#10;            // Filtrar cursos que aplican para este día&#10;            List&lt;Course&gt; coursesForDay = filterCoursesForDay(activeCourses, dayOfWeek);&#10;&#10;            // Organizar turno de mañana&#10;            List&lt;Schedule&gt; morningSchedules = organizeTimeSlot(&#10;                    coursesForDay.stream().filter(c -&gt; c.getTurno() == Turno.MANANA).collect(Collectors.toList()),&#10;                    dayOfWeek, MORNING_START, MORNING_END);&#10;            generatedSchedules.addAll(morningSchedules);&#10;&#10;            // Organizar turno de tarde&#10;            List&lt;Schedule&gt; afternoonSchedules = organizeTimeSlot(&#10;                    coursesForDay.stream().filter(c -&gt; c.getTurno() == Turno.TARDE).collect(Collectors.toList()),&#10;                    dayOfWeek, AFTERNOON_START, AFTERNOON_END);&#10;            generatedSchedules.addAll(afternoonSchedules);&#10;        }&#10;&#10;        // Guardar todos los horarios&#10;        generatedSchedules = scheduleRepository.saveAll(generatedSchedules);&#10;&#10;        log.info(&quot;Se han generado {} horarios para la semana&quot;, generatedSchedules.size());&#10;        return generatedSchedules;&#10;    }&#10;&#10;    /**&#10;     * Filtra los cursos que aplican para un día específico.&#10;     */&#10;    private List&lt;Course&gt; filterCoursesForDay(List&lt;Course&gt; courses, DayOfWeek dayOfWeek) {&#10;        return courses.stream()&#10;                .filter(c -&gt; {&#10;                    // Summer camp todos los días&#10;                    if (c.getCourseType() == CourseType.SUMMER_CAMP) {&#10;                        return true;&#10;                    }&#10;                    // Otros cursos solo L-V&#10;                    return dayOfWeek != DayOfWeek.SATURDAY &amp;&amp; dayOfWeek != DayOfWeek.SUNDAY;&#10;                })&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Organiza las clases dentro de un slot de tiempo.&#10;     */&#10;    private List&lt;Schedule&gt; organizeTimeSlot(List&lt;Course&gt; courses, DayOfWeek dayOfWeek,&#10;                                             LocalTime slotStart, LocalTime slotEnd) {&#10;        List&lt;Schedule&gt; schedules = new ArrayList&lt;&gt;();&#10;&#10;        if (courses.isEmpty()) {&#10;            return schedules;&#10;        }&#10;&#10;        // Ordenar cursos por prioridad (más estudiantes primero, luego por tipo)&#10;        courses.sort((c1, c2) -&gt; {&#10;            int studentsCompare = Integer.compare(&#10;                    c2.getStudentIds().size(), &#10;                    c1.getStudentIds().size()&#10;            );&#10;            if (studentsCompare != 0) return studentsCompare;&#10;            return c1.getCourseType().compareTo(c2.getCourseType());&#10;        });&#10;&#10;        // Track de tiempo disponible&#10;        LocalTime currentTime = slotStart;&#10;&#10;        for (Course course : courses) {&#10;            int durationMinutes = course.getDurationMinutes() != null ? course.getDurationMinutes() : 60;&#10;&#10;            // Verificar si cabe en el slot&#10;            LocalTime endTime = currentTime.plusMinutes(durationMinutes);&#10;            if (endTime.isAfter(slotEnd)) {&#10;                log.warn(&quot;No hay espacio para {} en el turno&quot;, course.getName());&#10;                continue;&#10;            }&#10;&#10;            // Crear horario&#10;            Schedule schedule = Schedule.builder()&#10;                    .course(course)&#10;                    .dayOfWeek(dayOfWeek)&#10;                    .startTime(currentTime)&#10;                    .endTime(endTime)&#10;                    .confirmed(false)&#10;                    .notes(generateScheduleNotes(course))&#10;                    .build();&#10;&#10;            schedules.add(schedule);&#10;&#10;            // Avanzar tiempo&#10;            currentTime = endTime.plusMinutes(MIN_GAP_BETWEEN_CLASSES);&#10;        }&#10;&#10;        return schedules;&#10;    }&#10;&#10;    /**&#10;     * Reorganiza el horario de un día específico optimizando recursos.&#10;     */&#10;    @Transactional&#10;    public List&lt;Schedule&gt; reorganizeDaySchedule(LocalDate date) {&#10;        DayOfWeek dayOfWeek = date.getDayOfWeek();&#10;&#10;        // Eliminar horarios existentes para ese día&#10;        List&lt;Schedule&gt; existing = scheduleRepository.findByDayOfWeek(dayOfWeek);&#10;        scheduleRepository.deleteAll(existing);&#10;&#10;        // Obtener cursos activos&#10;        List&lt;Course&gt; activeCourses = courseRepository.findByActiveTrue();&#10;        List&lt;Course&gt; coursesForDay = filterCoursesForDay(activeCourses, dayOfWeek);&#10;&#10;        List&lt;Schedule&gt; newSchedules = new ArrayList&lt;&gt;();&#10;&#10;        // Mañana&#10;        newSchedules.addAll(organizeTimeSlot(&#10;                coursesForDay.stream().filter(c -&gt; c.getTurno() == Turno.MANANA).collect(Collectors.toList()),&#10;                dayOfWeek, MORNING_START, MORNING_END));&#10;&#10;        // Tarde&#10;        newSchedules.addAll(organizeTimeSlot(&#10;                coursesForDay.stream().filter(c -&gt; c.getTurno() == Turno.TARDE).collect(Collectors.toList()),&#10;                dayOfWeek, AFTERNOON_START, AFTERNOON_END));&#10;&#10;        return scheduleRepository.saveAll(newSchedules);&#10;    }&#10;&#10;    /**&#10;     * Obtiene la disponibilidad de slots para un día.&#10;     */&#10;    public List&lt;TimeSlot&gt; getAvailableSlots(LocalDate date, Turno turno) {&#10;        DayOfWeek dayOfWeek = date.getDayOfWeek();&#10;        List&lt;Schedule&gt; existingSchedules = scheduleRepository.findByDayOfWeek(dayOfWeek);&#10;&#10;        LocalTime slotStart = turno == Turno.MANANA ? MORNING_START : AFTERNOON_START;&#10;        LocalTime slotEnd = turno == Turno.MANANA ? MORNING_END : AFTERNOON_END;&#10;&#10;        // Ordenar horarios existentes&#10;        existingSchedules.sort(Comparator.comparing(Schedule::getStartTime));&#10;&#10;        List&lt;TimeSlot&gt; availableSlots = new ArrayList&lt;&gt;();&#10;        LocalTime currentStart = slotStart;&#10;&#10;        for (Schedule schedule : existingSchedules) {&#10;            if (schedule.getStartTime().isAfter(currentStart)) {&#10;                // Hay un hueco&#10;                availableSlots.add(new TimeSlot(currentStart, schedule.getStartTime()));&#10;            }&#10;            currentStart = schedule.getEndTime().plusMinutes(MIN_GAP_BETWEEN_CLASSES);&#10;        }&#10;&#10;        // Slot final si queda tiempo&#10;        if (currentStart.isBefore(slotEnd)) {&#10;            availableSlots.add(new TimeSlot(currentStart, slotEnd));&#10;        }&#10;&#10;        return availableSlots;&#10;    }&#10;&#10;    /**&#10;     * Verifica si hay conflictos de horario para un profesor.&#10;     */&#10;    public boolean hasScheduleConflict(Long teacherId, DayOfWeek dayOfWeek, &#10;                                        LocalTime startTime, LocalTime endTime) {&#10;        List&lt;Schedule&gt; teacherSchedules = scheduleRepository.findByTeacherId(teacherId);&#10;&#10;        return teacherSchedules.stream()&#10;                .filter(s -&gt; s.getDayOfWeek() == dayOfWeek)&#10;                .anyMatch(s -&gt; {&#10;                    // Verificar solapamiento&#10;                    return !(endTime.isBefore(s.getStartTime()) || startTime.isAfter(s.getEndTime()));&#10;                });&#10;    }&#10;&#10;    /**&#10;     * Obtiene estadísticas de ocupación.&#10;     */&#10;    public Map&lt;DayOfWeek, OccupancyStats&gt; getWeekOccupancyStats() {&#10;        Map&lt;DayOfWeek, OccupancyStats&gt; stats = new HashMap&lt;&gt;();&#10;&#10;        for (DayOfWeek day : DayOfWeek.values()) {&#10;            List&lt;Schedule&gt; daySchedules = scheduleRepository.findByDayOfWeek(day);&#10;            &#10;            int totalMinutes = daySchedules.stream()&#10;                    .mapToInt(s -&gt; (int) java.time.Duration.between(s.getStartTime(), s.getEndTime()).toMinutes())&#10;                    .sum();&#10;&#10;            int availableMinutes = (int) java.time.Duration.between(MORNING_START, MORNING_END).toMinutes()&#10;                    + (int) java.time.Duration.between(AFTERNOON_START, AFTERNOON_END).toMinutes();&#10;&#10;            double occupancyRate = (double) totalMinutes / availableMinutes * 100;&#10;&#10;            stats.put(day, new OccupancyStats(daySchedules.size(), totalMinutes, occupancyRate));&#10;        }&#10;&#10;        return stats;&#10;    }&#10;&#10;    private String generateScheduleNotes(Course course) {&#10;        StringBuilder notes = new StringBuilder();&#10;        notes.append(&quot;Tipo: &quot;).append(course.getCourseType().getDisplayName());&#10;        notes.append(&quot; | Estudiantes: &quot;).append(course.getStudentIds().size());&#10;        if (course.getMaxStudents() != null) {&#10;            notes.append(&quot;/&quot;).append(course.getMaxStudents());&#10;        }&#10;        return notes.toString();&#10;    }&#10;&#10;    // Clases auxiliares&#10;    public record TimeSlot(LocalTime start, LocalTime end) {&#10;        public int getDurationMinutes() {&#10;            return (int) java.time.Duration.between(start, end).toMinutes();&#10;        }&#10;    }&#10;&#10;    public record OccupancyStats(int classCount, int totalMinutes, double occupancyRate) {}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/ScheduleServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Impl/ScheduleServiceImpl.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Service.Impl;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Schedule;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Events.ScheduleEvent;&#10;import com.empresa.course.MicroserviceCourseApi.Kafka.Producer.CourseEventProducer;&#10;import com.empresa.course.MicroserviceCourseApi.Repository.ScheduleRepository;&#10;import com.empresa.course.MicroserviceCourseApi.Service.Inter.ScheduleService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class ScheduleServiceImpl implements ScheduleService {&#10;&#10;    private final ScheduleRepository scheduleRepository;&#10;    private final CourseEventProducer eventProducer;&#10;&#10;    @Override&#10;    public List&lt;Schedule&gt; findAll() {&#10;        return scheduleRepository.findAll();&#10;    }&#10;&#10;    @Override&#10;    public Schedule findById(Long id) {&#10;        return scheduleRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Horario no encontrado: &quot; + id));&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Schedule&gt; findByCourseId(Long courseId) {&#10;        return scheduleRepository.findByCourseId(courseId);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Schedule&gt; findByTeacherId(Long teacherId) {&#10;        return scheduleRepository.findByTeacherId(teacherId);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public Schedule create(Schedule schedule) {&#10;        Schedule saved = scheduleRepository.save(schedule);&#10;        &#10;        // Publicar evento para notificar al profesor&#10;        if (schedule.getTeacherId() != null) {&#10;            ScheduleEvent event = ScheduleEvent.builder()&#10;                    .eventType(&quot;SCHEDULE_CREATED&quot;)&#10;                    .timestamp(LocalDateTime.now())&#10;                    .scheduleId(saved.getId())&#10;                    .courseId(saved.getCourse() != null ? saved.getCourse().getId() : null)&#10;                    .teacherId(saved.getTeacherId())&#10;                    .confirmationRequired(true)&#10;                    .confirmationDeadline(LocalDateTime.now().plusHours(24))&#10;                    .build();&#10;            &#10;            eventProducer.publishScheduleEvent(event);&#10;        }&#10;        &#10;        return saved;&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public Schedule update(Long id, Schedule schedule) {&#10;        Schedule existing = findById(id);&#10;        existing.setDayOfWeek(schedule.getDayOfWeek());&#10;        existing.setStartTime(schedule.getStartTime());&#10;        existing.setEndTime(schedule.getEndTime());&#10;        existing.setTeacherId(schedule.getTeacherId());&#10;        existing.setNotes(schedule.getNotes());&#10;        return scheduleRepository.save(existing);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void delete(Long id) {&#10;        if (!scheduleRepository.existsById(id)) {&#10;            throw new RuntimeException(&quot;Horario no encontrado: &quot; + id);&#10;        }&#10;        scheduleRepository.deleteById(id);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void confirmTeacherSchedule(Long teacherId, boolean confirmed) {&#10;        List&lt;Schedule&gt; schedules = scheduleRepository.findByTeacherIdAndConfirmedFalse(teacherId);&#10;        schedules.forEach(s -&gt; s.setConfirmed(confirmed));&#10;        scheduleRepository.saveAll(schedules);&#10;        log.info(&quot;Horarios del profesor {} confirmados: {}&quot;, teacherId, confirmed);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void handleTeacherRejection(Long teacherId, String reason) {&#10;        log.info(&quot;Profesor {} rechazó horario. Motivo: {}&quot;, teacherId, reason);&#10;        &#10;        List&lt;Schedule&gt; schedules = scheduleRepository.findByTeacherIdAndConfirmedFalse(teacherId);&#10;        &#10;        for (Schedule schedule : schedules) {&#10;            // Publicar evento para reasignación&#10;            ScheduleEvent event = ScheduleEvent.builder()&#10;                    .eventType(&quot;TEACHER_UNAVAILABLE&quot;)&#10;                    .timestamp(LocalDateTime.now())&#10;                    .scheduleId(schedule.getId())&#10;                    .teacherId(teacherId)&#10;                    .rejectionReason(reason)&#10;                    .build();&#10;            &#10;            eventProducer.publishScheduleEvent(event);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void reassignTeacher(Long scheduleId, Long originalTeacherId) {&#10;        log.info(&quot;Reasignando horario {} del profesor {}&quot;, scheduleId, originalTeacherId);&#10;        &#10;        Schedule schedule = findById(scheduleId);&#10;        &#10;        // Aquí se debería llamar al servicio de asignación de profesores vía Kafka&#10;        // Por ahora marcamos como pendiente de asignación&#10;        schedule.setTeacherId(null);&#10;        schedule.setConfirmed(false);&#10;        schedule.setNotes(&quot;Pendiente de reasignación - Profesor original: &quot; + originalTeacherId);&#10;        scheduleRepository.save(schedule);&#10;        &#10;        // Publicar evento solicitando nuevo profesor&#10;        ScheduleEvent event = ScheduleEvent.builder()&#10;                .eventType(&quot;TEACHER_ASSIGNMENT_REQUESTED&quot;)&#10;                .timestamp(LocalDateTime.now())&#10;                .scheduleId(scheduleId)&#10;                .courseId(schedule.getCourse() != null ? schedule.getCourse().getId() : null)&#10;                .build();&#10;        &#10;        eventProducer.publishScheduleEvent(event);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Inter/ScheduleService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/java/com/empresa/course/MicroserviceCourseApi/Service/Inter/ScheduleService.java" />
              <option name="updatedContent" value="package com.empresa.course.MicroserviceCourseApi.Service.Inter;&#10;&#10;import com.empresa.course.MicroserviceCourseApi.Entities.Schedule;&#10;&#10;import java.util.List;&#10;&#10;public interface ScheduleService {&#10;    &#10;    List&lt;Schedule&gt; findAll();&#10;    &#10;    Schedule findById(Long id);&#10;    &#10;    List&lt;Schedule&gt; findByCourseId(Long courseId);&#10;    &#10;    List&lt;Schedule&gt; findByTeacherId(Long teacherId);&#10;    &#10;    Schedule create(Schedule schedule);&#10;    &#10;    Schedule update(Long id, Schedule schedule);&#10;    &#10;    void delete(Long id);&#10;    &#10;    void confirmTeacherSchedule(Long teacherId, boolean confirmed);&#10;    &#10;    void handleTeacherRejection(Long teacherId, String reason);&#10;    &#10;    void reassignTeacher(Long scheduleId, Long originalTeacherId);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceCourseApi/src/main/resources/application.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceCourseApi/src/main/resources/application.yml" />
              <option name="originalContent" value="server:&#10;  port: 8083&#10;&#10;spring:&#10;  application:&#10;    name: msvc-course&#10;  datasource:&#10;    driver-class-name: org.postgresql.Driver&#10;    url: jdbc:postgresql://localhost:5432/tfgdb&#10;    username: postgres&#10;    password: curso&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: create-drop&#10;    show-sql: true&#10;    database: postgresql&#10;    database-platform: org.hibernate.dialect.PostgreSQLDialect&#10;&#10;eureka:&#10;  instance:&#10;    hostname: localhost&#10;  client:&#10;      serviceUrl:&#10;          defaultZone: http://localhost:8761/eureka/&#10;" />
              <option name="updatedContent" value="server:&#10;  port: 8083&#10;&#10;spring:&#10;  application:&#10;    name: msvc-course&#10;  datasource:&#10;    driver-class-name: org.postgresql.Driver&#10;    url: jdbc:postgresql://localhost:5432/tfgdb&#10;    username: postgres&#10;    password: curso&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: update&#10;    show-sql: true&#10;    database: postgresql&#10;    database-platform: org.hibernate.dialect.PostgreSQLDialect&#10;  kafka:&#10;    bootstrap-servers: localhost:29092&#10;    consumer:&#10;      group-id: course-group&#10;      auto-offset-reset: earliest&#10;      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer&#10;      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer&#10;      properties:&#10;        spring.json.trusted.packages: &quot;*&quot;&#10;    producer:&#10;      key-serializer: org.apache.kafka.common.serialization.StringSerializer&#10;      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;jwt:&#10;  secret: RVZTX0xhQW50aWxsYV9TZWNyZXRLZXlfMjAyNF9URkdfU2FpbGluZ1NjaG9vbF9KV1RfVG9rZW5fS2V5&#10;  expiration: 86400000&#10;&#10;# Configuración de la playa - La Antilla&#10;sailing:&#10;  beach:&#10;    name: La Antilla&#10;    latitude: 37.2074&#10;    longitude: -7.2193&#10;    orientation: 180  # Orientación en grados (Sur)&#10;&#10;eureka:&#10;  instance:&#10;    hostname: localhost&#10;  client:&#10;    serviceUrl:&#10;      defaultZone: http://localhost:8761/eureka/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.example&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.empresa.students&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;MicroserviceStudentsAPI&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;MicroserviceStudentsAPI&lt;/name&gt;&#10;&#9;&lt;description&gt;api encargada de gestionar el registro de estudiantes&lt;/description&gt;&#10;&#9;&lt;url/&gt;&#10;&#9;&lt;licenses&gt;&#10;&#9;&#9;&lt;license/&gt;&#10;&#9;&lt;/licenses&gt;&#10;&#9;&lt;developers&gt;&#10;&#9;&#9;&lt;developer/&gt;&#10;&#9;&lt;/developers&gt;&#10;&#9;&lt;scm&gt;&#10;&#9;&#9;&lt;connection/&gt;&#10;&#9;&#9;&lt;developerConnection/&gt;&#10;&#9;&#9;&lt;tag/&gt;&#10;&#9;&#9;&lt;url/&gt;&#10;&#9;&lt;/scm&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.example&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.empresa.students&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;MicroserviceStudentsAPI&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;MicroserviceStudentsAPI&lt;/name&gt;&#10;&#9;&lt;description&gt;api encargada de gestionar el registro de estudiantes&lt;/description&gt;&#10;&#9;&lt;url/&gt;&#10;&#9;&lt;licenses&gt;&#10;&#9;&#9;&lt;license/&gt;&#10;&#9;&lt;/licenses&gt;&#10;&#9;&lt;developers&gt;&#10;&#9;&#9;&lt;developer/&gt;&#10;&#9;&lt;/developers&gt;&#10;&#9;&lt;scm&gt;&#10;&#9;&#9;&lt;connection/&gt;&#10;&#9;&#9;&lt;developerConnection/&gt;&#10;&#9;&#9;&lt;tag/&gt;&#10;&#9;&#9;&lt;url/&gt;&#10;&#9;&lt;/scm&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Kafka --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Security --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Validation --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- PostgreSQL (unificado) --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Controller/DTO/StudentRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Controller/DTO/StudentRequest.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Controller.DTO;&#10;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Enums.SkillLevel;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class StudentRequest {&#10;&#10;    @NotBlank(message = &quot;El nombre es obligatorio&quot;)&#10;    private String name;&#10;&#10;    private String lastName;&#10;&#10;    private String dni;&#10;&#10;    @Email(message = &quot;El email debe ser válido&quot;)&#10;    private String email;&#10;&#10;    private String password;&#10;&#10;    private Boolean socio;&#10;&#10;    private String phone1;&#10;&#10;    private String phone2;&#10;&#10;    private SkillLevel skillLevel;&#10;&#10;    private LocalDate birthDate;&#10;&#10;    private Set&lt;Long&gt; courseIds;&#10;&#10;    private String notes;&#10;&#10;    private String emergencyContact;&#10;&#10;    private String emergencyPhone;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Controller/DTO/StudentResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Controller/DTO/StudentResponse.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Controller.DTO;&#10;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Enums.SkillLevel;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class StudentResponse {&#10;    private Long id;&#10;    private String name;&#10;    private String lastName;&#10;    private String dni;&#10;    private String email;&#10;    private Boolean socio;&#10;    private String phone1;&#10;    private String phone2;&#10;    private SkillLevel skillLevel;&#10;    private LocalDate birthDate;&#10;    private Set&lt;Long&gt; courseIds;&#10;    private String notes;&#10;    private String emergencyContact;&#10;    private String emergencyPhone;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Controller/StudentController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Controller/StudentController.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Controller;&#10;&#10;import com.empresa.students.MicroserviceStudentsAPI.Controller.DTO.StudentRequest;&#10;import com.empresa.students.MicroserviceStudentsAPI.Controller.DTO.StudentResponse;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Enums.SkillLevel;&#10;import com.empresa.students.MicroserviceStudentsAPI.Service.StudentService;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/students&quot;)&#10;@RequiredArgsConstructor&#10;public class StudentController {&#10;&#10;    private final StudentService studentService;&#10;&#10;    @GetMapping&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;StudentResponse&gt;&gt; findAll() {&#10;        return ResponseEntity.ok(studentService.findAll());&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER', 'STUDENT')&quot;)&#10;    public ResponseEntity&lt;StudentResponse&gt; findById(@PathVariable Long id) {&#10;        return ResponseEntity.ok(studentService.findById(id));&#10;    }&#10;&#10;    @PostMapping&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;StudentResponse&gt; create(@Valid @RequestBody StudentRequest request) {&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(studentService.create(request));&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;StudentResponse&gt; update(@PathVariable Long id,&#10;                                                   @Valid @RequestBody StudentRequest request) {&#10;        return ResponseEntity.ok(studentService.update(id, request));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; delete(@PathVariable Long id) {&#10;        studentService.delete(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/level/{skillLevel}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;StudentResponse&gt;&gt; findBySkillLevel(@PathVariable SkillLevel skillLevel) {&#10;        return ResponseEntity.ok(studentService.findBySkillLevel(skillLevel));&#10;    }&#10;&#10;    @GetMapping(&quot;/course/{courseId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;StudentResponse&gt;&gt; findByCourseId(@PathVariable Long courseId) {&#10;        return ResponseEntity.ok(studentService.findByCourseId(courseId));&#10;    }&#10;&#10;    @GetMapping(&quot;/socios&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;StudentResponse&gt;&gt; findSocios() {&#10;        return ResponseEntity.ok(studentService.findSocios());&#10;    }&#10;&#10;    @GetMapping(&quot;/search&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;StudentResponse&gt;&gt; searchByName(@RequestParam String name) {&#10;        return ResponseEntity.ok(studentService.searchByName(name));&#10;    }&#10;&#10;    @PostMapping(&quot;/{studentId}/enroll/{courseId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; enrollInCourse(@PathVariable Long studentId,&#10;                                                @PathVariable Long courseId) {&#10;        studentService.enrollInCourse(studentId, courseId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{studentId}/unenroll/{courseId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; unenrollFromCourse(@PathVariable Long studentId,&#10;                                                    @PathVariable Long courseId) {&#10;        studentService.unenrollFromCourse(studentId, courseId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    @PatchMapping(&quot;/{id}/level&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; updateSkillLevel(@PathVariable Long id,&#10;                                                  @RequestParam SkillLevel skillLevel) {&#10;        studentService.updateSkillLevel(id, skillLevel);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Entities/Enums/SkillLevel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Entities/Enums/SkillLevel.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Entities.Enums;&#10;&#10;/**&#10; * Nivel de habilidad del estudiante en navegación&#10; */&#10;public enum SkillLevel {&#10;    BEGINNER(&quot;Principiante&quot;, 1),&#10;    INTERMEDIATE(&quot;Intermedio&quot;, 2),&#10;    ADVANCED(&quot;Avanzado&quot;, 3),&#10;    EXPERT(&quot;Experto&quot;, 4);&#10;&#10;    private final String displayName;&#10;    private final int level;&#10;&#10;    SkillLevel(String displayName, int level) {&#10;        this.displayName = displayName;&#10;        this.level = level;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;&#10;    public int getLevel() {&#10;        return level;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Entities/Student.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Entities/Student.java" />
              <option name="originalContent" value="package com.empresa.students.MicroserviceStudentsAPI.Entities;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;students&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Student {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long Id;&#10;    private String Name;&#10;&#10;    @Column(name = &quot;last_name&quot;)&#10;    private String lastName;&#10;    private boolean Socio;&#10;    private String Email;&#10;&#10;    @Column(name = &quot;tlf_contacto_1&quot;)&#10;    private int Phone1;&#10;&#10;    @Column(name = &quot;tlf_contacto_2&quot;)&#10;    private int Phone2;&#10;    private String CurseLevel;&#10;&#10;    @Column(name = &quot;id_course&quot;)&#10;    private Long IdCourse;&#10;}&#10;" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Entities;&#10;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Enums.SkillLevel;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.time.LocalDate;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;students&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Student {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;    &#10;    @Column(nullable = false)&#10;    private String name;&#10;&#10;    @Column(name = &quot;last_name&quot;)&#10;    private String lastName;&#10;    &#10;    @Column(unique = true)&#10;    private String dni;&#10;    &#10;    @Column(unique = true)&#10;    private String email;&#10;    &#10;    private String password;&#10;    &#10;    private Boolean socio = false;&#10;&#10;    @Column(name = &quot;tlf_contacto_1&quot;)&#10;    private String phone1;&#10;&#10;    @Column(name = &quot;tlf_contacto_2&quot;)&#10;    private String phone2;&#10;&#10;    // Nivel de habilidad del estudiante&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;skill_level&quot;)&#10;    private SkillLevel skillLevel = SkillLevel.BEGINNER;&#10;&#10;    // Fecha de nacimiento para campamentos de verano&#10;    @Column(name = &quot;birth_date&quot;)&#10;    private LocalDate birthDate;&#10;&#10;    // IDs de los cursos en los que está inscrito&#10;    @ElementCollection(fetch = FetchType.EAGER)&#10;    @CollectionTable(name = &quot;student_courses&quot;, joinColumns = @JoinColumn(name = &quot;student_id&quot;))&#10;    @Column(name = &quot;course_id&quot;)&#10;    private Set&lt;Long&gt; courseIds = new HashSet&lt;&gt;();&#10;&#10;    // Notas o comentarios sobre el estudiante&#10;    @Column(length = 1000)&#10;    private String notes;&#10;&#10;    // Contacto de emergencia&#10;    @Column(name = &quot;emergency_contact&quot;)&#10;    private String emergencyContact;&#10;&#10;    @Column(name = &quot;emergency_phone&quot;)&#10;    private String emergencyPhone;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Exception/GlobalExceptionHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Exception/GlobalExceptionHandler.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Exception;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.AccessDeniedException;&#10;import org.springframework.validation.FieldError;&#10;import org.springframework.web.bind.MethodArgumentNotValidException;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice&#10;public class GlobalExceptionHandler {&#10;&#10;    @ExceptionHandler(RuntimeException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleRuntimeException(RuntimeException ex) {&#10;        log.error(&quot;Error de runtime: {}&quot;, ex.getMessage());&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.BAD_REQUEST.value(),&#10;                ex.getMessage(),&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.badRequest().body(error);&#10;    }&#10;&#10;    @ExceptionHandler(MethodArgumentNotValidException.class)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        ex.getBindingResult().getAllErrors().forEach(error -&gt; {&#10;            String fieldName = ((FieldError) error).getField();&#10;            String errorMessage = error.getDefaultMessage();&#10;            errors.put(fieldName, errorMessage);&#10;        });&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;status&quot;, HttpStatus.BAD_REQUEST.value());&#10;        response.put(&quot;errors&quot;, errors);&#10;        response.put(&quot;timestamp&quot;, LocalDateTime.now());&#10;        &#10;        return ResponseEntity.badRequest().body(response);&#10;    }&#10;&#10;    @ExceptionHandler(AccessDeniedException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleAccessDenied(AccessDeniedException ex) {&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.FORBIDDEN.value(),&#10;                &quot;Acceso denegado&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception ex) {&#10;        log.error(&quot;Error inesperado: {}&quot;, ex.getMessage(), ex);&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.INTERNAL_SERVER_ERROR.value(),&#10;                &quot;Error interno del servidor&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);&#10;    }&#10;&#10;    public record ErrorResponse(int status, String message, LocalDateTime timestamp) {}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Repository/StudentRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Repository/StudentRepository.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Repository;&#10;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Enums.SkillLevel;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Student;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface StudentRepository extends JpaRepository&lt;Student, Long&gt; {&#10;    &#10;    Optional&lt;Student&gt; findByEmail(String email);&#10;    &#10;    Optional&lt;Student&gt; findByDni(String dni);&#10;    &#10;    boolean existsByEmail(String email);&#10;    &#10;    boolean existsByDni(String dni);&#10;    &#10;    // Buscar por nivel de habilidad&#10;    List&lt;Student&gt; findBySkillLevel(SkillLevel skillLevel);&#10;    &#10;    // Buscar estudiantes inscritos en un curso&#10;    @Query(&quot;SELECT s FROM Student s WHERE :courseId MEMBER OF s.courseIds&quot;)&#10;    List&lt;Student&gt; findByCourseId(@Param(&quot;courseId&quot;) Long courseId);&#10;    &#10;    // Buscar socios&#10;    List&lt;Student&gt; findBySocioTrue();&#10;    &#10;    // Buscar por nombre (búsqueda parcial)&#10;    List&lt;Student&gt; findByNameContainingIgnoreCase(String name);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Security/JwtAuthenticationFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Security/JwtAuthenticationFilter.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Security;&#10;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.lang.NonNull;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import java.io.IOException;&#10;import java.util.List;&#10;&#10;@Component&#10;@RequiredArgsConstructor&#10;public class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;&#10;    private final JwtService jwtService;&#10;&#10;    @Override&#10;    protected void doFilterInternal(&#10;            @NonNull HttpServletRequest request,&#10;            @NonNull HttpServletResponse response,&#10;            @NonNull FilterChain filterChain&#10;    ) throws ServletException, IOException {&#10;        &#10;        final String authHeader = request.getHeader(&quot;Authorization&quot;);&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            filterChain.doFilter(request, response);&#10;            return;&#10;        }&#10;&#10;        final String jwt = authHeader.substring(7);&#10;        &#10;        try {&#10;            if (jwtService.isTokenValid(jwt) &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {&#10;                String username = jwtService.extractUsername(jwt);&#10;                String role = jwtService.extractRole(jwt);&#10;&#10;                var authorities = List.of(new SimpleGrantedAuthority(&quot;ROLE_&quot; + (role != null ? role : &quot;USER&quot;)));&#10;&#10;                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(&#10;                        username,&#10;                        null,&#10;                        authorities&#10;                );&#10;                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));&#10;                SecurityContextHolder.getContext().setAuthentication(authToken);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error validando token JWT: &quot; + e.getMessage());&#10;        }&#10;&#10;        filterChain.doFilter(request, response);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Security/JwtService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Security/JwtService.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Security;&#10;&#10;import io.jsonwebtoken.Claims;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.io.Decoders;&#10;import io.jsonwebtoken.security.Keys;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;import java.util.function.Function;&#10;&#10;@Service&#10;public class JwtService {&#10;&#10;    @Value(&quot;${jwt.secret}&quot;)&#10;    private String secretKey;&#10;&#10;    public String extractUsername(String token) {&#10;        return extractClaim(token, Claims::getSubject);&#10;    }&#10;&#10;    public String extractRole(String token) {&#10;        Claims claims = extractAllClaims(token);&#10;        return claims.get(&quot;role&quot;, String.class);&#10;    }&#10;&#10;    public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {&#10;        final Claims claims = extractAllClaims(token);&#10;        return claimsResolver.apply(claims);&#10;    }&#10;&#10;    public boolean isTokenValid(String token) {&#10;        try {&#10;            return !isTokenExpired(token);&#10;        } catch (Exception e) {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private boolean isTokenExpired(String token) {&#10;        return extractExpiration(token).before(new Date());&#10;    }&#10;&#10;    private Date extractExpiration(String token) {&#10;        return extractClaim(token, Claims::getExpiration);&#10;    }&#10;&#10;    private Claims extractAllClaims(String token) {&#10;        return Jwts.parser()&#10;                .verifyWith(getSignInKey())&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;    }&#10;&#10;    private SecretKey getSignInKey() {&#10;        byte[] keyBytes = Decoders.BASE64.decode(secretKey);&#10;        return Keys.hmacShaKeyFor(keyBytes);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Security/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Security/SecurityConfig.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Security;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.List;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableMethodSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final JwtAuthenticationFilter jwtAuthFilter;&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .csrf(AbstractHttpConfigurer::disable)&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .requestMatchers(&quot;/actuator/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()&#10;                .anyRequest().authenticated()&#10;            )&#10;            .sessionManagement(session -&gt; session&#10;                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;            )&#10;            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);&#10;&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(List.of(&quot;*&quot;));&#10;        configuration.setAllowedMethods(List.of(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;, &quot;OPTIONS&quot;));&#10;        configuration.setAllowedHeaders(List.of(&quot;*&quot;));&#10;        configuration.setExposedHeaders(List.of(&quot;Authorization&quot;));&#10;        &#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Service/StudentService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/java/com/empresa/students/MicroserviceStudentsAPI/Service/StudentService.java" />
              <option name="updatedContent" value="package com.empresa.students.MicroserviceStudentsAPI.Service;&#10;&#10;import com.empresa.students.MicroserviceStudentsAPI.Controller.DTO.StudentRequest;&#10;import com.empresa.students.MicroserviceStudentsAPI.Controller.DTO.StudentResponse;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Enums.SkillLevel;&#10;import com.empresa.students.MicroserviceStudentsAPI.Entities.Student;&#10;import com.empresa.students.MicroserviceStudentsAPI.Repository.StudentRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class StudentService {&#10;&#10;    private final StudentRepository studentRepository;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    public List&lt;StudentResponse&gt; findAll() {&#10;        return studentRepository.findAll().stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public StudentResponse findById(Long id) {&#10;        Student student = studentRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Estudiante no encontrado: &quot; + id));&#10;        return toResponse(student);&#10;    }&#10;&#10;    @Transactional&#10;    public StudentResponse create(StudentRequest request) {&#10;        if (request.getEmail() != null &amp;&amp; studentRepository.existsByEmail(request.getEmail())) {&#10;            throw new RuntimeException(&quot;El email ya está registrado&quot;);&#10;        }&#10;        if (request.getDni() != null &amp;&amp; studentRepository.existsByDni(request.getDni())) {&#10;            throw new RuntimeException(&quot;El DNI ya está registrado&quot;);&#10;        }&#10;&#10;        Student student = Student.builder()&#10;                .name(request.getName())&#10;                .lastName(request.getLastName())&#10;                .dni(request.getDni())&#10;                .email(request.getEmail())&#10;                .password(request.getPassword() != null ? passwordEncoder.encode(request.getPassword()) : null)&#10;                .socio(request.getSocio() != null ? request.getSocio() : false)&#10;                .phone1(request.getPhone1())&#10;                .phone2(request.getPhone2())&#10;                .skillLevel(request.getSkillLevel() != null ? request.getSkillLevel() : SkillLevel.BEGINNER)&#10;                .birthDate(request.getBirthDate())&#10;                .courseIds(request.getCourseIds() != null ? request.getCourseIds() : new HashSet&lt;&gt;())&#10;                .notes(request.getNotes())&#10;                .emergencyContact(request.getEmergencyContact())&#10;                .emergencyPhone(request.getEmergencyPhone())&#10;                .build();&#10;&#10;        return toResponse(studentRepository.save(student));&#10;    }&#10;&#10;    @Transactional&#10;    public StudentResponse update(Long id, StudentRequest request) {&#10;        Student student = studentRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Estudiante no encontrado: &quot; + id));&#10;&#10;        student.setName(request.getName());&#10;        student.setLastName(request.getLastName());&#10;        student.setPhone1(request.getPhone1());&#10;        student.setPhone2(request.getPhone2());&#10;        if (request.getSkillLevel() != null) {&#10;            student.setSkillLevel(request.getSkillLevel());&#10;        }&#10;        if (request.getBirthDate() != null) {&#10;            student.setBirthDate(request.getBirthDate());&#10;        }&#10;        if (request.getSocio() != null) {&#10;            student.setSocio(request.getSocio());&#10;        }&#10;        student.setNotes(request.getNotes());&#10;        student.setEmergencyContact(request.getEmergencyContact());&#10;        student.setEmergencyPhone(request.getEmergencyPhone());&#10;&#10;        return toResponse(studentRepository.save(student));&#10;    }&#10;&#10;    @Transactional&#10;    public void delete(Long id) {&#10;        if (!studentRepository.existsById(id)) {&#10;            throw new RuntimeException(&quot;Estudiante no encontrado: &quot; + id);&#10;        }&#10;        studentRepository.deleteById(id);&#10;    }&#10;&#10;    public List&lt;StudentResponse&gt; findBySkillLevel(SkillLevel skillLevel) {&#10;        return studentRepository.findBySkillLevel(skillLevel).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;StudentResponse&gt; findByCourseId(Long courseId) {&#10;        return studentRepository.findByCourseId(courseId).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;StudentResponse&gt; findSocios() {&#10;        return studentRepository.findBySocioTrue().stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    public List&lt;StudentResponse&gt; searchByName(String name) {&#10;        return studentRepository.findByNameContainingIgnoreCase(name).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    @Transactional&#10;    public void enrollInCourse(Long studentId, Long courseId) {&#10;        Student student = studentRepository.findById(studentId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Estudiante no encontrado: &quot; + studentId));&#10;        student.getCourseIds().add(courseId);&#10;        studentRepository.save(student);&#10;    }&#10;&#10;    @Transactional&#10;    public void unenrollFromCourse(Long studentId, Long courseId) {&#10;        Student student = studentRepository.findById(studentId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Estudiante no encontrado: &quot; + studentId));&#10;        student.getCourseIds().remove(courseId);&#10;        studentRepository.save(student);&#10;    }&#10;&#10;    @Transactional&#10;    public void updateSkillLevel(Long studentId, SkillLevel newLevel) {&#10;        Student student = studentRepository.findById(studentId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Estudiante no encontrado: &quot; + studentId));&#10;        student.setSkillLevel(newLevel);&#10;        studentRepository.save(student);&#10;        log.info(&quot;Nivel de {} actualizado a {}&quot;, student.getName(), newLevel);&#10;    }&#10;&#10;    private StudentResponse toResponse(Student student) {&#10;        return StudentResponse.builder()&#10;                .id(student.getId())&#10;                .name(student.getName())&#10;                .lastName(student.getLastName())&#10;                .dni(student.getDni())&#10;                .email(student.getEmail())&#10;                .socio(student.getSocio())&#10;                .phone1(student.getPhone1())&#10;                .phone2(student.getPhone2())&#10;                .skillLevel(student.getSkillLevel())&#10;                .birthDate(student.getBirthDate())&#10;                .courseIds(student.getCourseIds())&#10;                .notes(student.getNotes())&#10;                .emergencyContact(student.getEmergencyContact())&#10;                .emergencyPhone(student.getEmergencyPhone())&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/resources/application.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceStudentsAPI/src/main/resources/application.yml" />
              <option name="originalContent" value="server:&#10;  port: 8081&#10;&#10;spring:&#10;  application:&#10;    name: msvc-students-api&#10;  datasource:&#10;    driver-class-name: com.mysql.cj.jdbc.Driver&#10;    url: jdbc:mysql://localhost:3306/TFGDB&#10;    username: root&#10;    password: curso&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: create-drop&#10;    database: mysql&#10;    database-platform: org.hibernate.dialect.MySQL8Dialect&#10;&#10;eureka:&#10;  instance:&#10;    hostname: localhost&#10;  client:&#10;    service-url:&#10;        defaultZone: http://localhost:8761/eureka/&#10;" />
              <option name="updatedContent" value="server:&#10;  port: 8081&#10;&#10;spring:&#10;  application:&#10;    name: msvc-students-api&#10;  datasource:&#10;    driver-class-name: org.postgresql.Driver&#10;    url: jdbc:postgresql://localhost:5432/tfgdb&#10;    username: postgres&#10;    password: curso&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: update&#10;    show-sql: true&#10;    database: postgresql&#10;    database-platform: org.hibernate.dialect.PostgreSQLDialect&#10;  kafka:&#10;    bootstrap-servers: localhost:29092&#10;    consumer:&#10;      group-id: students-group&#10;      auto-offset-reset: earliest&#10;      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer&#10;      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer&#10;      properties:&#10;        spring.json.trusted.packages: &quot;*&quot;&#10;    producer:&#10;      key-serializer: org.apache.kafka.common.serialization.StringSerializer&#10;      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer&#10;&#10;jwt:&#10;  secret: RVZTX0xhQW50aWxsYV9TZWNyZXRLZXlfMjAyNF9URkdfU2FpbGluZ1NjaG9vbF9KV1RfVG9rZW5fS2V5&#10;  expiration: 86400000&#10;&#10;eureka:&#10;  instance:&#10;    hostname: localhost&#10;  client:&#10;    service-url:&#10;      defaultZone: http://localhost:8761/eureka/&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.example&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.empresa.teacher&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;MicroserviceTeacherRegisterAPI&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;MicroserviceTeacherRegisterAPI&lt;/name&gt;&#10;&#9;&lt;description&gt;api encargada de gestionar el registro de los profesores&lt;/description&gt;&#10;&#9;&lt;url/&gt;&#10;&#9;&lt;licenses&gt;&#10;&#9;&#9;&lt;license/&gt;&#10;&#9;&lt;/licenses&gt;&#10;&#9;&lt;developers&gt;&#10;&#9;&#9;&lt;developer/&gt;&#10;&#9;&lt;/developers&gt;&#10;&#9;&lt;scm&gt;&#10;&#9;&#9;&lt;connection/&gt;&#10;&#9;&#9;&lt;developerConnection/&gt;&#10;&#9;&#9;&lt;tag/&gt;&#10;&#9;&#9;&lt;url/&gt;&#10;&#9;&lt;/scm&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;com.mysql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;&#9;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;&#9;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#9;&lt;parent&gt;&#10;&#9;&#9;&lt;groupId&gt;org.example&lt;/groupId&gt;&#10;&#9;&#9;&lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;&#9;&#9;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;/parent&gt;&#10;&#9;&lt;groupId&gt;com.empresa.teacher&lt;/groupId&gt;&#10;&#9;&lt;artifactId&gt;MicroserviceTeacherRegisterAPI&lt;/artifactId&gt;&#10;&#9;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#10;&#9;&lt;name&gt;MicroserviceTeacherRegisterAPI&lt;/name&gt;&#10;&#9;&lt;description&gt;api encargada de gestionar el registro de los profesores&lt;/description&gt;&#10;&#9;&lt;url/&gt;&#10;&#9;&lt;licenses&gt;&#10;&#9;&#9;&lt;license/&gt;&#10;&#9;&lt;/licenses&gt;&#10;&#9;&lt;developers&gt;&#10;&#9;&#9;&lt;developer/&gt;&#10;&#9;&lt;/developers&gt;&#10;&#9;&lt;scm&gt;&#10;&#9;&#9;&lt;connection/&gt;&#10;&#9;&#9;&lt;developerConnection/&gt;&#10;&#9;&#9;&lt;tag/&gt;&#10;&#9;&#9;&lt;url/&gt;&#10;&#9;&lt;/scm&gt;&#10;&#9;&lt;properties&gt;&#10;&#9;&#9;&lt;java.version&gt;17&lt;/java.version&gt;&#10;&#9;&#9;&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;&#9;&lt;/properties&gt;&#10;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Kafka --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Security --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- JWT --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Validation --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- Mail para notificaciones --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#10;&#9;&#9;&lt;!-- PostgreSQL (unificado) --&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;runtime&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;&#10;&#9;&#9;&#9;&lt;artifactId&gt;spring-kafka-test&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;scope&gt;test&lt;/scope&gt;&#10;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;dependencyManagement&gt;&#10;&#9;&#9;&lt;dependencies&gt;&#10;&#9;&#9;&#9;&lt;dependency&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&#9;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;&#9;&#9;&#9;&#9;&lt;type&gt;pom&lt;/type&gt;&#10;&#9;&#9;&#9;&#9;&lt;scope&gt;import&lt;/scope&gt;&#10;&#9;&#9;&#9;&lt;/dependency&gt;&#10;&#9;&#9;&lt;/dependencies&gt;&#10;&#9;&lt;/dependencyManagement&gt;&#10;&#10;&#9;&lt;build&gt;&#10;&#9;&#9;&lt;plugins&gt;&#10;&#9;&#9;&#9;&lt;plugin&gt;&#10;&#9;&#9;&#9;&#9;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;&#9;&#9;&#9;&#9;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;&#9;&#9;&#9;&lt;/plugin&gt;&#10;&#9;&#9;&lt;/plugins&gt;&#10;&#9;&lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/AuthController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/AuthController.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.AuthRequest;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.AuthResponse;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.TeacherRequest;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service.AuthService;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/auth&quot;)&#10;@RequiredArgsConstructor&#10;public class AuthController {&#10;&#10;    private final AuthService authService;&#10;&#10;    /**&#10;     * Registra un nuevo profesor&#10;     */&#10;    @PostMapping(&quot;/register/teacher&quot;)&#10;    public ResponseEntity&lt;AuthResponse&gt; registerTeacher(@Valid @RequestBody TeacherRequest request) {&#10;        return ResponseEntity.ok(authService.registerTeacher(request));&#10;    }&#10;&#10;    /**&#10;     * Inicia sesión&#10;     */&#10;    @PostMapping(&quot;/login&quot;)&#10;    public ResponseEntity&lt;AuthResponse&gt; login(@Valid @RequestBody AuthRequest request) {&#10;        return ResponseEntity.ok(authService.login(request));&#10;    }&#10;&#10;    /**&#10;     * Registra un administrador (endpoint protegido en producción)&#10;     */&#10;    @PostMapping(&quot;/register/admin&quot;)&#10;    public ResponseEntity&lt;AuthResponse&gt; registerAdmin(&#10;            @RequestParam String email,&#10;            @RequestParam String password,&#10;            @RequestParam String name) {&#10;        return ResponseEntity.ok(authService.registerAdmin(email, password, name));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/AuthRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/AuthRequest.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class AuthRequest {&#10;    &#10;    @NotBlank(message = &quot;El email es obligatorio&quot;)&#10;    @Email(message = &quot;El email debe ser válido&quot;)&#10;    private String email;&#10;    &#10;    @NotBlank(message = &quot;La contraseña es obligatoria&quot;)&#10;    private String password;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/AuthResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/AuthResponse.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Role;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class AuthResponse {&#10;    private String token;&#10;    private String email;&#10;    private String name;&#10;    private Role role;&#10;    private Long userId;&#10;    private Long referenceId;&#10;    private Long expiresIn;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/TeacherRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/TeacherRequest.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.NotBlank;&#10;import jakarta.validation.constraints.NotNull;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class TeacherRequest {&#10;    &#10;    @NotBlank(message = &quot;El nombre es obligatorio&quot;)&#10;    private String name;&#10;    &#10;    private String lastName;&#10;    &#10;    @NotBlank(message = &quot;El DNI es obligatorio&quot;)&#10;    private String dni;&#10;    &#10;    private String phone;&#10;    &#10;    @NotBlank(message = &quot;El email es obligatorio&quot;)&#10;    @Email(message = &quot;El email debe ser válido&quot;)&#10;    private String email;&#10;    &#10;    @NotBlank(message = &quot;La contraseña es obligatoria&quot;)&#10;    private String password;&#10;    &#10;    @NotNull(message = &quot;Las especialidades son obligatorias&quot;)&#10;    private Set&lt;Speciality&gt; specialities;&#10;    &#10;    @NotNull(message = &quot;El tipo de contrato es obligatorio&quot;)&#10;    private ContractType contractType;&#10;    &#10;    private Integer maxWeeklyHours;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/TeacherResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/DTO/TeacherResponse.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class TeacherResponse {&#10;    private Long id;&#10;    private String name;&#10;    private String lastName;&#10;    private String dni;&#10;    private String phone;&#10;    private String email;&#10;    private Set&lt;Speciality&gt; specialities;&#10;    private ContractType contractType;&#10;    private Integer workedHours;&#10;    private Integer maxWeeklyHours;&#10;    private Boolean available;&#10;    private Boolean confirmedAvailability;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/NotificationController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/NotificationController.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Producer.TeacherEventProducer;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service.NotificationService;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/notifications&quot;)&#10;@RequiredArgsConstructor&#10;public class NotificationController {&#10;&#10;    private final NotificationService notificationService;&#10;    private final TeacherEventProducer eventProducer;&#10;&#10;    /**&#10;     * Envía el horario a un profesor&#10;     */&#10;    @PostMapping(&quot;/send-schedule/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; sendScheduleNotification(&#10;            @PathVariable Long teacherId,&#10;            @RequestBody String scheduleDetails) {&#10;        notificationService.sendScheduleNotification(teacherId, scheduleDetails);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    /**&#10;     * Envía recordatorio de confirmación&#10;     */&#10;    @PostMapping(&quot;/send-reminder/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; sendConfirmationReminder(@PathVariable Long teacherId) {&#10;        notificationService.sendConfirmationRequest(teacherId);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    /**&#10;     * Envía recordatorios a todos los profesores pendientes&#10;     */&#10;    @PostMapping(&quot;/send-pending-reminders&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; sendPendingReminders() {&#10;        notificationService.sendPendingConfirmationReminders();&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    /**&#10;     * Profesor confirma o rechaza su horario&#10;     */&#10;    @PostMapping(&quot;/confirm/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; confirmSchedule(&#10;            @PathVariable Long teacherId,&#10;            @RequestParam boolean confirmed,&#10;            @RequestParam(required = false) String reason) {&#10;        // Publicar evento Kafka&#10;        eventProducer.publishScheduleConfirmation(teacherId, confirmed, reason);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    /**&#10;     * Envía plan de ruta a un profesor&#10;     */&#10;    @PostMapping(&quot;/send-route-plan/{teacherId}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; sendRoutePlan(&#10;            @PathVariable Long teacherId,&#10;            @RequestParam String routeSummary,&#10;            @RequestParam(required = false) String imageBase64) {&#10;        notificationService.sendRoutePlan(teacherId, routeSummary, imageBase64);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/TeacherController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Controller/TeacherController.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.TeacherRequest;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.TeacherResponse;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Teacher;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service.TeacherAssignmentService;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service.TeacherService;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/teachers&quot;)&#10;@RequiredArgsConstructor&#10;public class TeacherController {&#10;&#10;    private final TeacherService teacherService;&#10;    private final TeacherAssignmentService assignmentService;&#10;&#10;    /**&#10;     * Obtener todos los profesores&#10;     */&#10;    @GetMapping&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;TeacherResponse&gt;&gt; findAll() {&#10;        return ResponseEntity.ok(teacherService.findAll());&#10;    }&#10;&#10;    /**&#10;     * Obtener profesor por ID&#10;     */&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;TeacherResponse&gt; findById(@PathVariable Long id) {&#10;        return ResponseEntity.ok(teacherService.findById(id));&#10;    }&#10;&#10;    /**&#10;     * Crear profesor&#10;     */&#10;    @PostMapping&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;TeacherResponse&gt; create(@Valid @RequestBody TeacherRequest request) {&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(teacherService.create(request));&#10;    }&#10;&#10;    /**&#10;     * Actualizar profesor&#10;     */&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;TeacherResponse&gt; update(@PathVariable Long id, &#10;                                                   @Valid @RequestBody TeacherRequest request) {&#10;        return ResponseEntity.ok(teacherService.update(id, request));&#10;    }&#10;&#10;    /**&#10;     * Eliminar profesor&#10;     */&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; delete(@PathVariable Long id) {&#10;        teacherService.delete(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    /**&#10;     * Obtener profesores disponibles por especialidad&#10;     */&#10;    @GetMapping(&quot;/available/{speciality}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;TeacherResponse&gt;&gt; findAvailableBySpeciality(&#10;            @PathVariable Speciality speciality) {&#10;        return ResponseEntity.ok(teacherService.findAvailableBySpeciality(speciality));&#10;    }&#10;&#10;    /**&#10;     * Obtener profesores por tipo de contrato&#10;     */&#10;    @GetMapping(&quot;/contract/{contractType}&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;List&lt;TeacherResponse&gt;&gt; findByContractType(&#10;            @PathVariable ContractType contractType) {&#10;        return ResponseEntity.ok(teacherService.findByContractType(contractType));&#10;    }&#10;&#10;    /**&#10;     * Actualizar disponibilidad del profesor&#10;     */&#10;    @PatchMapping(&quot;/{id}/availability&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; updateAvailability(@PathVariable Long id, &#10;                                                    @RequestParam boolean available) {&#10;        teacherService.updateAvailability(id, available);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    /**&#10;     * Confirmar disponibilidad para horario&#10;     */&#10;    @PostMapping(&quot;/{id}/confirm-schedule&quot;)&#10;    @PreAuthorize(&quot;hasAnyRole('ADMIN', 'TEACHER')&quot;)&#10;    public ResponseEntity&lt;Void&gt; confirmSchedule(@PathVariable Long id, &#10;                                                 @RequestParam boolean confirmed) {&#10;        teacherService.confirmAvailability(id, confirmed);&#10;        return ResponseEntity.ok().build();&#10;    }&#10;&#10;    /**&#10;     * Asignar profesor automáticamente para una clase&#10;     */&#10;    @PostMapping(&quot;/assign&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;?&gt; assignTeacher(@RequestParam Speciality speciality,&#10;                                           @RequestParam int durationMinutes) {&#10;        Optional&lt;Teacher&gt; teacher = assignmentService.assignTeacher(speciality, durationMinutes);&#10;        return teacher&#10;                .map(t -&gt; ResponseEntity.ok(teacherService.findById(t.getId())))&#10;                .orElse(ResponseEntity.notFound().build());&#10;    }&#10;&#10;    /**&#10;     * Asignar múltiples profesores para una clase&#10;     */&#10;    @PostMapping(&quot;/assign-multiple&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;List&lt;TeacherResponse&gt;&gt; assignMultipleTeachers(&#10;            @RequestParam Speciality speciality,&#10;            @RequestParam int durationMinutes,&#10;            @RequestParam int count) {&#10;        List&lt;Teacher&gt; teachers = assignmentService.assignMultipleTeachers(speciality, durationMinutes, count);&#10;        List&lt;TeacherResponse&gt; responses = teachers.stream()&#10;                .map(t -&gt; teacherService.findById(t.getId()))&#10;                .toList();&#10;        return ResponseEntity.ok(responses);&#10;    }&#10;&#10;    /**&#10;     * Reasignar profesor&#10;     */&#10;    @PostMapping(&quot;/reassign&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;?&gt; reassignTeacher(@RequestParam Long originalTeacherId,&#10;                                              @RequestParam Speciality speciality,&#10;                                              @RequestParam int durationMinutes) {&#10;        Optional&lt;Teacher&gt; teacher = assignmentService.reassignTeacher(originalTeacherId, speciality, durationMinutes);&#10;        return teacher&#10;                .map(t -&gt; ResponseEntity.ok(teacherService.findById(t.getId())))&#10;                .orElse(ResponseEntity.notFound().build());&#10;    }&#10;&#10;    /**&#10;     * Obtener estadísticas de distribución de horas&#10;     */&#10;    @GetMapping(&quot;/stats/hours-distribution&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Map&lt;ContractType, Double&gt;&gt; getHoursDistribution() {&#10;        return ResponseEntity.ok(assignmentService.getHoursDistributionStats());&#10;    }&#10;&#10;    /**&#10;     * Resetear horas trabajadas (inicio de semana)&#10;     */&#10;    @PostMapping(&quot;/reset-hours&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public ResponseEntity&lt;Void&gt; resetWorkedHours() {&#10;        teacherService.resetAllWorkedHours();&#10;        return ResponseEntity.ok().build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Enums/ContractType.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Enums/ContractType.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums;&#10;&#10;/**&#10; * Tipo de contrato del profesor con orden de prioridad&#10; * Los fijos tienen mayor prioridad, seguidos de temporales y prácticas&#10; */&#10;public enum ContractType {&#10;    FIJO(1, &quot;Fijo&quot;),&#10;    TEMPORAL(2, &quot;Temporal&quot;),&#10;    PRACTICAS(3, &quot;Prácticas&quot;);&#10;&#10;    private final int priority;&#10;    private final String displayName;&#10;&#10;    ContractType(int priority, String displayName) {&#10;        this.priority = priority;&#10;        this.displayName = displayName;&#10;    }&#10;&#10;    public int getPriority() {&#10;        return priority;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Enums/Role.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Enums/Role.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums;&#10;&#10;/**&#10; * Roles del sistema para autenticación y autorización&#10; */&#10;public enum Role {&#10;    ADMIN,&#10;    TEACHER,&#10;    STUDENT&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Enums/Speciality.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Enums/Speciality.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums;&#10;&#10;/**&#10; * Especialidades de navegación que puede tener un profesor&#10; */&#10;public enum Speciality {&#10;    WINDSURF(&quot;Windsurf&quot;),&#10;    CATAMARAN(&quot;Catamarán&quot;),&#10;    MINICATA(&quot;Minicatamarán&quot;),&#10;    OPTIMIST(&quot;Optimist&quot;),&#10;    PADDLE_SURF(&quot;Paddle Surf&quot;),&#10;    KAYAK(&quot;Kayak&quot;),&#10;    SUMMER_CAMP(&quot;Campamento de Verano&quot;),&#10;    VELA_LIGERA(&quot;Vela Ligera&quot;);&#10;&#10;    private final String displayName;&#10;&#10;    Speciality(String displayName) {&#10;        this.displayName = displayName;&#10;    }&#10;&#10;    public String getDisplayName() {&#10;        return displayName;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Teacher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/Teacher.java" />
              <option name="originalContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities;&#10;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;teachers&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Teacher {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long Id;&#10;&#10;    @Column(name = &quot;teacher_name&quot;)&#10;    private String name;&#10;    private String lastName;&#10;    private String dni;&#10;&#10;    @Column(name = &quot;phone_number&quot;)&#10;    private String phone;&#10;    private String email;&#10;    private String speciality;&#10;&#10;    @Column(name = &quot;id_course&quot;)&#10;    private Long IdCourse;&#10;}" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Role;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.util.HashSet;&#10;import java.util.Set;&#10;&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;teachers&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class Teacher {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(name = &quot;teacher_name&quot;, nullable = false)&#10;    private String name;&#10;    &#10;    @Column(name = &quot;last_name&quot;)&#10;    private String lastName;&#10;    &#10;    @Column(unique = true)&#10;    private String dni;&#10;&#10;    @Column(name = &quot;phone_number&quot;)&#10;    private String phone;&#10;    &#10;    @Column(unique = true)&#10;    private String email;&#10;    &#10;    @Column(nullable = false)&#10;    private String password;&#10;&#10;    // Especialidades del profesor (puede tener varias)&#10;    @ElementCollection(targetClass = Speciality.class, fetch = FetchType.EAGER)&#10;    @CollectionTable(name = &quot;teacher_specialities&quot;, joinColumns = @JoinColumn(name = &quot;teacher_id&quot;))&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;speciality&quot;)&#10;    private Set&lt;Speciality&gt; specialities = new HashSet&lt;&gt;();&#10;&#10;    // Tipo de contrato con prioridad&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(name = &quot;contract_type&quot;, nullable = false)&#10;    private ContractType contractType;&#10;&#10;    // Rol para autenticación&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private Role role = Role.TEACHER;&#10;&#10;    // Horas trabajadas en el periodo actual&#10;    @Column(name = &quot;worked_hours&quot;)&#10;    private Integer workedHours = 0;&#10;&#10;    // Horas máximas por semana según contrato&#10;    @Column(name = &quot;max_weekly_hours&quot;)&#10;    private Integer maxWeeklyHours = 40;&#10;&#10;    // Disponibilidad actual&#10;    @Column(name = &quot;available&quot;)&#10;    private Boolean available = true;&#10;&#10;    // Si ha confirmado disponibilidad para el próximo horario&#10;    @Column(name = &quot;confirmed_availability&quot;)&#10;    private Boolean confirmedAvailability = false;&#10;&#10;    @Column(name = &quot;id_course&quot;)&#10;    private Long idCourse;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Entities/User.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Role;&#10;import jakarta.persistence.*;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.security.core.GrantedAuthority;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;&#10;import java.util.Collection;&#10;import java.util.List;&#10;&#10;/**&#10; * Entidad de usuario para autenticación&#10; * Implementa UserDetails para integración con Spring Security&#10; */&#10;@Data&#10;@Entity&#10;@Builder&#10;@Table(name = &quot;users&quot;)&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class User implements UserDetails {&#10;&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Column(unique = true, nullable = false)&#10;    private String email;&#10;&#10;    @Column(nullable = false)&#10;    private String password;&#10;&#10;    @Column(nullable = false)&#10;    private String name;&#10;&#10;    @Column(name = &quot;last_name&quot;)&#10;    private String lastName;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @Column(nullable = false)&#10;    private Role role;&#10;&#10;    // ID del profesor o estudiante asociado (según el rol)&#10;    @Column(name = &quot;reference_id&quot;)&#10;    private Long referenceId;&#10;&#10;    private Boolean enabled = true;&#10;&#10;    @Override&#10;    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {&#10;        return List.of(new SimpleGrantedAuthority(&quot;ROLE_&quot; + role.name()));&#10;    }&#10;&#10;    @Override&#10;    public String getUsername() {&#10;        return email;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonLocked() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isCredentialsNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isEnabled() {&#10;        return enabled;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Exception/GlobalExceptionHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Exception/GlobalExceptionHandler.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Exception;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.security.access.AccessDeniedException;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.validation.FieldError;&#10;import org.springframework.web.bind.MethodArgumentNotValidException;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice&#10;public class GlobalExceptionHandler {&#10;&#10;    @ExceptionHandler(RuntimeException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleRuntimeException(RuntimeException ex) {&#10;        log.error(&quot;Error de runtime: {}&quot;, ex.getMessage());&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.BAD_REQUEST.value(),&#10;                ex.getMessage(),&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.badRequest().body(error);&#10;    }&#10;&#10;    @ExceptionHandler(MethodArgumentNotValidException.class)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        ex.getBindingResult().getAllErrors().forEach(error -&gt; {&#10;            String fieldName = ((FieldError) error).getField();&#10;            String errorMessage = error.getDefaultMessage();&#10;            errors.put(fieldName, errorMessage);&#10;        });&#10;        &#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        response.put(&quot;status&quot;, HttpStatus.BAD_REQUEST.value());&#10;        response.put(&quot;errors&quot;, errors);&#10;        response.put(&quot;timestamp&quot;, LocalDateTime.now());&#10;        &#10;        return ResponseEntity.badRequest().body(response);&#10;    }&#10;&#10;    @ExceptionHandler(BadCredentialsException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleBadCredentials(BadCredentialsException ex) {&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.UNAUTHORIZED.value(),&#10;                &quot;Credenciales inválidas&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);&#10;    }&#10;&#10;    @ExceptionHandler(AccessDeniedException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleAccessDenied(AccessDeniedException ex) {&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.FORBIDDEN.value(),&#10;                &quot;Acceso denegado&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception ex) {&#10;        log.error(&quot;Error inesperado: {}&quot;, ex.getMessage(), ex);&#10;        ErrorResponse error = new ErrorResponse(&#10;                HttpStatus.INTERNAL_SERVER_ERROR.value(),&#10;                &quot;Error interno del servidor&quot;,&#10;                LocalDateTime.now()&#10;        );&#10;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);&#10;    }&#10;&#10;    public record ErrorResponse(int status, String message, LocalDateTime timestamp) {}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Config/KafkaTopicConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Config/KafkaTopicConfig.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Config;&#10;&#10;import org.apache.kafka.clients.admin.NewTopic;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.kafka.config.TopicBuilder;&#10;&#10;@Configuration&#10;public class KafkaTopicConfig {&#10;&#10;    public static final String TEACHER_EVENTS_TOPIC = &quot;teacher-events&quot;;&#10;    public static final String SCHEDULE_EVENTS_TOPIC = &quot;schedule-events&quot;;&#10;    public static final String NOTIFICATION_EVENTS_TOPIC = &quot;notification-events&quot;;&#10;&#10;    @Bean&#10;    public NewTopic teacherEventsTopic() {&#10;        return TopicBuilder.name(TEACHER_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;&#10;    @Bean&#10;    public NewTopic scheduleEventsTopic() {&#10;        return TopicBuilder.name(SCHEDULE_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;&#10;    @Bean&#10;    public NewTopic notificationEventsTopic() {&#10;        return TopicBuilder.name(NOTIFICATION_EVENTS_TOPIC)&#10;                .partitions(3)&#10;                .replicas(1)&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Consumer/TeacherEventConsumer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Consumer/TeacherEventConsumer.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Consumer;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Config.KafkaTopicConfig;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Events.ScheduleEvent;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service.NotificationService;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service.TeacherService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.annotation.KafkaListener;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class TeacherEventConsumer {&#10;&#10;    private final TeacherService teacherService;&#10;    private final NotificationService notificationService;&#10;&#10;    @KafkaListener(&#10;        topics = KafkaTopicConfig.SCHEDULE_EVENTS_TOPIC,&#10;        groupId = &quot;teacher-group&quot;&#10;    )&#10;    public void consumeScheduleEvent(ScheduleEvent event) {&#10;        log.info(&quot;Evento de horario recibido: {} para profesor: {}&quot;, &#10;            event.getEventType(), event.getTeacherId());&#10;        &#10;        try {&#10;            switch (event.getEventType()) {&#10;                case &quot;SCHEDULE_CREATED&quot;:&#10;                    handleScheduleCreated(event);&#10;                    break;&#10;                case &quot;CONFIRMATION_REQUESTED&quot;:&#10;                    handleConfirmationRequested(event);&#10;                    break;&#10;                case &quot;TEACHER_ASSIGNMENT_REQUESTED&quot;:&#10;                    handleTeacherAssignmentRequested(event);&#10;                    break;&#10;                default:&#10;                    log.debug(&quot;Tipo de evento no manejado: {}&quot;, event.getEventType());&#10;            }&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error procesando evento de horario: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private void handleScheduleCreated(ScheduleEvent event) {&#10;        if (event.getTeacherId() == null) return;&#10;&#10;        // Construir detalles del horario&#10;        String scheduleDetails = &quot;&quot;;&#10;        if (event.getSchedules() != null &amp;&amp; !event.getSchedules().isEmpty()) {&#10;            scheduleDetails = event.getSchedules().stream()&#10;                    .map(s -&gt; String.format(&quot;- %s: %s - %s (%s)&quot;, &#10;                            s.getDayOfWeek(), s.getStartTime(), s.getEndTime(), s.getCourseName()))&#10;                    .collect(Collectors.joining(&quot;\n&quot;));&#10;        }&#10;&#10;        // Enviar notificación al profesor&#10;        notificationService.sendScheduleNotification(event.getTeacherId(), scheduleDetails);&#10;    }&#10;&#10;    private void handleConfirmationRequested(ScheduleEvent event) {&#10;        if (event.getTeacherId() == null) return;&#10;        notificationService.sendConfirmationRequest(event.getTeacherId());&#10;    }&#10;&#10;    private void handleTeacherAssignmentRequested(ScheduleEvent event) {&#10;        log.info(&quot;Solicitud de asignación de profesor para horario: {}&quot;, event.getScheduleId());&#10;        // Aquí se podría implementar lógica adicional de asignación&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Events/ScheduleEvent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Events/ScheduleEvent.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Events;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Data&#10;@Builder&#10;@AllArgsConstructor&#10;@NoArgsConstructor&#10;public class ScheduleEvent implements Serializable {&#10;    private String eventId;&#10;    private String eventType;&#10;    private LocalDateTime timestamp;&#10;    &#10;    private Long scheduleId;&#10;    private Long courseId;&#10;    private Long teacherId;&#10;    private String teacherEmail;&#10;    private String teacherName;&#10;    &#10;    private List&lt;ScheduleInfo&gt; schedules;&#10;    &#10;    private Boolean confirmationRequired;&#10;    private LocalDateTime confirmationDeadline;&#10;    &#10;    private Boolean confirmed;&#10;    private String rejectionReason;&#10;    &#10;    @Data&#10;    @Builder&#10;    @AllArgsConstructor&#10;    @NoArgsConstructor&#10;    public static class ScheduleInfo implements Serializable {&#10;        private String dayOfWeek;&#10;        private String startTime;&#10;        private String endTime;&#10;        private String courseName;&#10;        private String courseType;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Producer/TeacherEventProducer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Kafka/Producer/TeacherEventProducer.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Producer;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Config.KafkaTopicConfig;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Events.ScheduleEvent;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.kafka.core.KafkaTemplate;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class TeacherEventProducer {&#10;&#10;    private final KafkaTemplate&lt;String, Object&gt; kafkaTemplate;&#10;&#10;    /**&#10;     * Publica confirmación de horario de un profesor&#10;     */&#10;    public void publishScheduleConfirmation(Long teacherId, boolean confirmed, String reason) {&#10;        ScheduleEvent event = ScheduleEvent.builder()&#10;                .eventId(UUID.randomUUID().toString())&#10;                .eventType(&quot;CONFIRMATION_RECEIVED&quot;)&#10;                .timestamp(LocalDateTime.now())&#10;                .teacherId(teacherId)&#10;                .confirmed(confirmed)&#10;                .rejectionReason(reason)&#10;                .build();&#10;&#10;        kafkaTemplate.send(KafkaTopicConfig.SCHEDULE_EVENTS_TOPIC, teacherId.toString(), event);&#10;        log.info(&quot;Confirmación de horario publicada para profesor: {} - Confirmado: {}&quot;, teacherId, confirmed);&#10;    }&#10;&#10;    /**&#10;     * Publica evento de profesor no disponible&#10;     */&#10;    public void publishTeacherUnavailable(Long scheduleId, Long teacherId) {&#10;        ScheduleEvent event = ScheduleEvent.builder()&#10;                .eventId(UUID.randomUUID().toString())&#10;                .eventType(&quot;TEACHER_UNAVAILABLE&quot;)&#10;                .timestamp(LocalDateTime.now())&#10;                .scheduleId(scheduleId)&#10;                .teacherId(teacherId)&#10;                .build();&#10;&#10;        kafkaTemplate.send(KafkaTopicConfig.SCHEDULE_EVENTS_TOPIC, teacherId.toString(), event);&#10;        log.info(&quot;Evento de profesor no disponible publicado: {}&quot;, teacherId);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Repository/TeacherRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Repository/TeacherRepository.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Teacher;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.data.repository.query.Param;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface TeacherRepository extends JpaRepository&lt;Teacher, Long&gt; {&#10;    &#10;    Optional&lt;Teacher&gt; findByEmail(String email);&#10;    &#10;    Optional&lt;Teacher&gt; findByDni(String dni);&#10;    &#10;    boolean existsByEmail(String email);&#10;    &#10;    boolean existsByDni(String dni);&#10;    &#10;    // Buscar profesores disponibles&#10;    List&lt;Teacher&gt; findByAvailableTrue();&#10;    &#10;    // Buscar por tipo de contrato ordenados por horas trabajadas (equidad)&#10;    List&lt;Teacher&gt; findByContractTypeOrderByWorkedHoursAsc(ContractType contractType);&#10;    &#10;    // Buscar profesores por especialidad&#10;    @Query(&quot;SELECT t FROM Teacher t JOIN t.specialities s WHERE s = :speciality AND t.available = true&quot;)&#10;    List&lt;Teacher&gt; findBySpecialityAndAvailable(@Param(&quot;speciality&quot;) Speciality speciality);&#10;    &#10;    // Buscar profesores disponibles por especialidad ordenados por prioridad de contrato y horas trabajadas&#10;    @Query(&quot;SELECT t FROM Teacher t JOIN t.specialities s WHERE s = :speciality AND t.available = true &quot; +&#10;           &quot;ORDER BY t.contractType ASC, t.workedHours ASC&quot;)&#10;    List&lt;Teacher&gt; findAvailableBySpecialityOrderByPriorityAndHours(@Param(&quot;speciality&quot;) Speciality speciality);&#10;    &#10;    // Buscar profesores que no han confirmado disponibilidad&#10;    List&lt;Teacher&gt; findByConfirmedAvailabilityFalse();&#10;    &#10;    // Buscar por curso asignado&#10;    List&lt;Teacher&gt; findByIdCourse(Long courseId);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Repository/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Repository/UserRepository.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.User;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;&#10;import java.util.Optional;&#10;&#10;@Repository&#10;public interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    boolean existsByEmail(String email);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Security/JwtAuthenticationFilter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Security/JwtAuthenticationFilter.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Security;&#10;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.ServletException;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.lang.NonNull;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Filtro de autenticación JWT&#10; */&#10;@Component&#10;@RequiredArgsConstructor&#10;public class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;&#10;    private final JwtService jwtService;&#10;    private final UserDetailsService userDetailsService;&#10;&#10;    @Override&#10;    protected void doFilterInternal(&#10;            @NonNull HttpServletRequest request,&#10;            @NonNull HttpServletResponse response,&#10;            @NonNull FilterChain filterChain&#10;    ) throws ServletException, IOException {&#10;        &#10;        final String authHeader = request.getHeader(&quot;Authorization&quot;);&#10;        final String jwt;&#10;        final String userEmail;&#10;&#10;        if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;            filterChain.doFilter(request, response);&#10;            return;&#10;        }&#10;&#10;        jwt = authHeader.substring(7);&#10;        &#10;        try {&#10;            userEmail = jwtService.extractUsername(jwt);&#10;&#10;            if (userEmail != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {&#10;                UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);&#10;&#10;                if (jwtService.isTokenValid(jwt, userDetails)) {&#10;                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(&#10;                            userDetails,&#10;                            null,&#10;                            userDetails.getAuthorities()&#10;                    );&#10;                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));&#10;                    SecurityContextHolder.getContext().setAuthentication(authToken);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error validando token JWT: &quot; + e.getMessage());&#10;        }&#10;&#10;        filterChain.doFilter(request, response);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Security/JwtService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Security/JwtService.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Security;&#10;&#10;import io.jsonwebtoken.Claims;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.io.Decoders;&#10;import io.jsonwebtoken.security.Keys;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.stereotype.Service;&#10;&#10;import javax.crypto.SecretKey;&#10;import java.util.Date;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * Servicio para gestión de tokens JWT&#10; */&#10;@Service&#10;public class JwtService {&#10;&#10;    @Value(&quot;${jwt.secret}&quot;)&#10;    private String secretKey;&#10;&#10;    @Value(&quot;${jwt.expiration}&quot;)&#10;    private long jwtExpiration;&#10;&#10;    public String extractUsername(String token) {&#10;        return extractClaim(token, Claims::getSubject);&#10;    }&#10;&#10;    public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {&#10;        final Claims claims = extractAllClaims(token);&#10;        return claimsResolver.apply(claims);&#10;    }&#10;&#10;    public String generateToken(UserDetails userDetails) {&#10;        return generateToken(new HashMap&lt;&gt;(), userDetails);&#10;    }&#10;&#10;    public String generateToken(Map&lt;String, Object&gt; extraClaims, UserDetails userDetails) {&#10;        return buildToken(extraClaims, userDetails, jwtExpiration);&#10;    }&#10;&#10;    public long getExpirationTime() {&#10;        return jwtExpiration;&#10;    }&#10;&#10;    private String buildToken(Map&lt;String, Object&gt; extraClaims, UserDetails userDetails, long expiration) {&#10;        return Jwts.builder()&#10;                .claims(extraClaims)&#10;                .subject(userDetails.getUsername())&#10;                .issuedAt(new Date(System.currentTimeMillis()))&#10;                .expiration(new Date(System.currentTimeMillis() + expiration))&#10;                .signWith(getSignInKey(), Jwts.SIG.HS256)&#10;                .compact();&#10;    }&#10;&#10;    public boolean isTokenValid(String token, UserDetails userDetails) {&#10;        final String username = extractUsername(token);&#10;        return (username.equals(userDetails.getUsername())) &amp;&amp; !isTokenExpired(token);&#10;    }&#10;&#10;    private boolean isTokenExpired(String token) {&#10;        return extractExpiration(token).before(new Date());&#10;    }&#10;&#10;    private Date extractExpiration(String token) {&#10;        return extractClaim(token, Claims::getExpiration);&#10;    }&#10;&#10;    private Claims extractAllClaims(String token) {&#10;        return Jwts.parser()&#10;                .verifyWith(getSignInKey())&#10;                .build()&#10;                .parseSignedClaims(token)&#10;                .getPayload();&#10;    }&#10;&#10;    private SecretKey getSignInKey() {&#10;        byte[] keyBytes = Decoders.BASE64.decode(secretKey);&#10;        return Keys.hmacShaKeyFor(keyBytes);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Security/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Security/SecurityConfig.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Security;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository.UserRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.AuthenticationProvider;&#10;import org.springframework.security.authentication.dao.DaoAuthenticationProvider;&#10;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.core.userdetails.UsernameNotFoundException;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Configuración de seguridad&#10; */&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableMethodSecurity&#10;@RequiredArgsConstructor&#10;public class SecurityConfig {&#10;&#10;    private final UserRepository userRepository;&#10;    private final JwtAuthenticationFilter jwtAuthFilter;&#10;&#10;    @Bean&#10;    public UserDetailsService userDetailsService() {&#10;        return username -&gt; userRepository.findByEmail(username)&#10;                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;Usuario no encontrado: &quot; + username));&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .csrf(AbstractHttpConfigurer::disable)&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                // Endpoints públicos&#10;                .requestMatchers(&quot;/api/auth/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/actuator/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()&#10;                // Endpoints protegidos por rol&#10;                .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(&quot;/api/teacher/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;TEACHER&quot;)&#10;                .requestMatchers(&quot;/api/student/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;TEACHER&quot;, &quot;STUDENT&quot;)&#10;                // Cualquier otro endpoint requiere autenticación&#10;                .anyRequest().authenticated()&#10;            )&#10;            .sessionManagement(session -&gt; session&#10;                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;            )&#10;            .authenticationProvider(authenticationProvider())&#10;            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);&#10;&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOrigins(List.of(&quot;*&quot;));&#10;        configuration.setAllowedMethods(List.of(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));&#10;        configuration.setAllowedHeaders(List.of(&quot;*&quot;));&#10;        configuration.setExposedHeaders(List.of(&quot;Authorization&quot;));&#10;        &#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationProvider authenticationProvider() {&#10;        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();&#10;        authProvider.setUserDetailsService(userDetailsService());&#10;        authProvider.setPasswordEncoder(passwordEncoder());&#10;        return authProvider;&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {&#10;        return config.getAuthenticationManager();&#10;    }&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/AuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/AuthService.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.AuthRequest;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.AuthResponse;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.TeacherRequest;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Role;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Teacher;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.User;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository.TeacherRepository;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository.UserRepository;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Security.JwtService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;/**&#10; * Servicio de autenticación&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class AuthService {&#10;&#10;    private final UserRepository userRepository;&#10;    private final TeacherRepository teacherRepository;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JwtService jwtService;&#10;    private final AuthenticationManager authenticationManager;&#10;&#10;    /**&#10;     * Registra un nuevo profesor&#10;     */&#10;    @Transactional&#10;    public AuthResponse registerTeacher(TeacherRequest request) {&#10;        // Verificar que no existe el email&#10;        if (userRepository.existsByEmail(request.getEmail())) {&#10;            throw new RuntimeException(&quot;El email ya está registrado&quot;);&#10;        }&#10;        if (teacherRepository.existsByDni(request.getDni())) {&#10;            throw new RuntimeException(&quot;El DNI ya está registrado&quot;);&#10;        }&#10;&#10;        // Crear profesor&#10;        Teacher teacher = Teacher.builder()&#10;                .name(request.getName())&#10;                .lastName(request.getLastName())&#10;                .dni(request.getDni())&#10;                .phone(request.getPhone())&#10;                .email(request.getEmail())&#10;                .password(passwordEncoder.encode(request.getPassword()))&#10;                .specialities(request.getSpecialities())&#10;                .contractType(request.getContractType())&#10;                .maxWeeklyHours(request.getMaxWeeklyHours() != null ? request.getMaxWeeklyHours() : 40)&#10;                .workedHours(0)&#10;                .available(true)&#10;                .confirmedAvailability(false)&#10;                .role(Role.TEACHER)&#10;                .build();&#10;&#10;        teacher = teacherRepository.save(teacher);&#10;&#10;        // Crear usuario&#10;        User user = User.builder()&#10;                .email(request.getEmail())&#10;                .password(passwordEncoder.encode(request.getPassword()))&#10;                .name(request.getName())&#10;                .lastName(request.getLastName())&#10;                .role(Role.TEACHER)&#10;                .referenceId(teacher.getId())&#10;                .enabled(true)&#10;                .build();&#10;&#10;        user = userRepository.save(user);&#10;&#10;        // Generar token&#10;        String token = jwtService.generateToken(user);&#10;&#10;        return AuthResponse.builder()&#10;                .token(token)&#10;                .email(user.getEmail())&#10;                .name(user.getName())&#10;                .role(user.getRole())&#10;                .userId(user.getId())&#10;                .referenceId(teacher.getId())&#10;                .expiresIn(jwtService.getExpirationTime())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Inicia sesión&#10;     */&#10;    public AuthResponse login(AuthRequest request) {&#10;        authenticationManager.authenticate(&#10;                new UsernamePasswordAuthenticationToken(request.getEmail(), request.getPassword())&#10;        );&#10;&#10;        User user = userRepository.findByEmail(request.getEmail())&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Usuario no encontrado&quot;));&#10;&#10;        String token = jwtService.generateToken(user);&#10;&#10;        return AuthResponse.builder()&#10;                .token(token)&#10;                .email(user.getEmail())&#10;                .name(user.getName())&#10;                .role(user.getRole())&#10;                .userId(user.getId())&#10;                .referenceId(user.getReferenceId())&#10;                .expiresIn(jwtService.getExpirationTime())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Registra un administrador (solo para uso interno)&#10;     */&#10;    @Transactional&#10;    public AuthResponse registerAdmin(String email, String password, String name) {&#10;        if (userRepository.existsByEmail(email)) {&#10;            throw new RuntimeException(&quot;El email ya está registrado&quot;);&#10;        }&#10;&#10;        User user = User.builder()&#10;                .email(email)&#10;                .password(passwordEncoder.encode(password))&#10;                .name(name)&#10;                .role(Role.ADMIN)&#10;                .enabled(true)&#10;                .build();&#10;&#10;        user = userRepository.save(user);&#10;&#10;        String token = jwtService.generateToken(user);&#10;&#10;        return AuthResponse.builder()&#10;                .token(token)&#10;                .email(user.getEmail())&#10;                .name(user.getName())&#10;                .role(user.getRole())&#10;                .userId(user.getId())&#10;                .expiresIn(jwtService.getExpirationTime())&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/NotificationService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/NotificationService.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Teacher;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository.TeacherRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.mail.SimpleMailMessage;&#10;import org.springframework.mail.javamail.JavaMailSender;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Servicio de notificaciones para profesores&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class NotificationService {&#10;&#10;    private final JavaMailSender mailSender;&#10;    private final TeacherRepository teacherRepository;&#10;&#10;    @Value(&quot;${spring.mail.username:no-reply@evs-laantilla.com}&quot;)&#10;    private String fromEmail;&#10;&#10;    /**&#10;     * Envía el horario semanal a un profesor&#10;     */&#10;    public void sendScheduleNotification(Long teacherId, String scheduleDetails) {&#10;        Teacher teacher = teacherRepository.findById(teacherId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + teacherId));&#10;&#10;        String subject = &quot; Tu horario semanal - EVS La Antilla&quot;;&#10;        String body = String.format(&quot;&quot;&quot;&#10;                Hola %s,&#10;                &#10;                Aquí tienes tu horario para la próxima semana:&#10;                &#10;                %s&#10;                &#10;                Por favor, confirma tu disponibilidad respondiendo a este email o &#10;                accediendo a la aplicación.&#10;                &#10;                ⚠️ IMPORTANTE: Tienes 24 horas para confirmar tu disponibilidad.&#10;                Si no confirmas, se reasignarán tus clases a otro profesor.&#10;                &#10;                ¡Gracias!&#10;                &#10;                --&#10;                Escuela de Vela La Antilla&#10;                &quot;&quot;&quot;, teacher.getName(), scheduleDetails);&#10;&#10;        sendEmail(teacher.getEmail(), subject, body);&#10;        log.info(&quot;Horario enviado a {} ({})&quot;, teacher.getName(), teacher.getEmail());&#10;    }&#10;&#10;    /**&#10;     * Envía notificación de confirmación requerida&#10;     */&#10;    public void sendConfirmationRequest(Long teacherId) {&#10;        Teacher teacher = teacherRepository.findById(teacherId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + teacherId));&#10;&#10;        String subject = &quot;⏰ Confirmación pendiente - EVS La Antilla&quot;;&#10;        String body = String.format(&quot;&quot;&quot;&#10;                Hola %s,&#10;                &#10;                Recordatorio: Tienes un horario pendiente de confirmar.&#10;                &#10;                Por favor, accede a la aplicación para confirmar tu disponibilidad&#10;                antes de que se reasignen tus clases.&#10;                &#10;                --&#10;                Escuela de Vela La Antilla&#10;                &quot;&quot;&quot;, teacher.getName());&#10;&#10;        sendEmail(teacher.getEmail(), subject, body);&#10;    }&#10;&#10;    /**&#10;     * Envía notificación de reasignación&#10;     */&#10;    public void sendReassignmentNotification(Long teacherId, String reason) {&#10;        Teacher teacher = teacherRepository.findById(teacherId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + teacherId));&#10;&#10;        String subject = &quot; Reasignación de clases - EVS La Antilla&quot;;&#10;        String body = String.format(&quot;&quot;&quot;&#10;                Hola %s,&#10;                &#10;                Te informamos que tus clases han sido reasignadas a otro profesor.&#10;                &#10;                Motivo: %s&#10;                &#10;                Si tienes alguna pregunta, contacta con administración.&#10;                &#10;                --&#10;                Escuela de Vela La Antilla&#10;                &quot;&quot;&quot;, teacher.getName(), reason);&#10;&#10;        sendEmail(teacher.getEmail(), subject, body);&#10;    }&#10;&#10;    /**&#10;     * Envía plan de ruta a un profesor&#10;     */&#10;    public void sendRoutePlan(Long teacherId, String routeSummary, String imageBase64) {&#10;        Teacher teacher = teacherRepository.findById(teacherId)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + teacherId));&#10;&#10;        String subject = &quot; Plan de navegación para tu clase - EVS La Antilla&quot;;&#10;        String body = String.format(&quot;&quot;&quot;&#10;                Hola %s,&#10;                &#10;                Aquí tienes el plan de navegación para tu próxima clase:&#10;                &#10;                %s&#10;                &#10;                La imagen del recorrido está adjunta a este email.&#10;                &#10;                ¡Buena navegación!&#10;                &#10;                --&#10;                Escuela de Vela La Antilla&#10;                &quot;&quot;&quot;, teacher.getName(), routeSummary);&#10;&#10;        // En una implementación real, aquí se adjuntaría la imagen&#10;        sendEmail(teacher.getEmail(), subject, body);&#10;        log.info(&quot;Plan de ruta enviado a {} ({})&quot;, teacher.getName(), teacher.getEmail());&#10;    }&#10;&#10;    /**&#10;     * Envía recordatorio a profesores que no han confirmado&#10;     */&#10;    public void sendPendingConfirmationReminders() {&#10;        List&lt;Teacher&gt; pendingTeachers = teacherRepository.findByConfirmedAvailabilityFalse();&#10;        &#10;        for (Teacher teacher : pendingTeachers) {&#10;            try {&#10;                sendConfirmationRequest(teacher.getId());&#10;            } catch (Exception e) {&#10;                log.error(&quot;Error enviando recordatorio a {}: {}&quot;, teacher.getEmail(), e.getMessage());&#10;            }&#10;        }&#10;        &#10;        log.info(&quot;Enviados {} recordatorios de confirmación&quot;, pendingTeachers.size());&#10;    }&#10;&#10;    private void sendEmail(String to, String subject, String body) {&#10;        try {&#10;            SimpleMailMessage message = new SimpleMailMessage();&#10;            message.setFrom(fromEmail);&#10;            message.setTo(to);&#10;            message.setSubject(subject);&#10;            message.setText(body);&#10;            &#10;            mailSender.send(message);&#10;            log.debug(&quot;Email enviado a {}&quot;, to);&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error enviando email a {}: {}&quot;, to, e.getMessage());&#10;            // No lanzar excepción para no interrumpir el flujo&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/TeacherAssignmentService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/TeacherAssignmentService.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Teacher;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository.TeacherRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Servicio de asignación de profesores a clases.&#10; * Implementa un algoritmo que:&#10; * 1. Prioriza por tipo de contrato (FIJO &gt; TEMPORAL &gt; PRACTICAS)&#10; * 2. Distribuye equitativamente las horas de trabajo&#10; * 3. Respeta las especialidades de cada profesor&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class TeacherAssignmentService {&#10;&#10;    private final TeacherRepository teacherRepository;&#10;&#10;    /**&#10;     * Asigna el mejor profesor disponible para una clase.&#10;     * &#10;     * @param speciality Especialidad requerida para la clase&#10;     * @param durationMinutes Duración de la clase en minutos&#10;     * @return Optional con el profesor asignado o vacío si no hay disponible&#10;     */&#10;    @Transactional&#10;    public Optional&lt;Teacher&gt; assignTeacher(Speciality speciality, int durationMinutes) {&#10;        log.info(&quot;Buscando profesor para {} con duración {} minutos&quot;, speciality, durationMinutes);&#10;&#10;        // Obtener profesores disponibles con la especialidad, ordenados por prioridad y horas&#10;        List&lt;Teacher&gt; candidates = teacherRepository.findAvailableBySpecialityOrderByPriorityAndHours(speciality);&#10;&#10;        if (candidates.isEmpty()) {&#10;            log.warn(&quot;No hay profesores disponibles para {}&quot;, speciality);&#10;            return Optional.empty();&#10;        }&#10;&#10;        // Filtrar por horas máximas semanales&#10;        int hoursToAdd = durationMinutes / 60;&#10;        candidates = candidates.stream()&#10;                .filter(t -&gt; t.getWorkedHours() + hoursToAdd &lt;= t.getMaxWeeklyHours())&#10;                .collect(Collectors.toList());&#10;&#10;        if (candidates.isEmpty()) {&#10;            log.warn(&quot;Todos los profesores de {} han alcanzado su límite de horas&quot;, speciality);&#10;            return Optional.empty();&#10;        }&#10;&#10;        // Aplicar algoritmo de selección&#10;        Teacher selected = selectTeacher(candidates, hoursToAdd);&#10;&#10;        if (selected != null) {&#10;            // Actualizar horas trabajadas&#10;            selected.setWorkedHours(selected.getWorkedHours() + hoursToAdd);&#10;            teacherRepository.save(selected);&#10;            log.info(&quot;Profesor asignado: {} {} - Horas acumuladas: {}&quot;, &#10;                selected.getName(), selected.getLastName(), selected.getWorkedHours());&#10;        }&#10;&#10;        return Optional.ofNullable(selected);&#10;    }&#10;&#10;    /**&#10;     * Selecciona el profesor más adecuado según el algoritmo de prioridad y equidad.&#10;     */&#10;    private Teacher selectTeacher(List&lt;Teacher&gt; candidates, int hoursToAdd) {&#10;        if (candidates.isEmpty()) {&#10;            return null;&#10;        }&#10;&#10;        // Agrupar por tipo de contrato&#10;        Map&lt;ContractType, List&lt;Teacher&gt;&gt; byContract = candidates.stream()&#10;                .collect(Collectors.groupingBy(Teacher::getContractType));&#10;&#10;        // Procesar en orden de prioridad&#10;        for (ContractType contractType : ContractType.values()) {&#10;            List&lt;Teacher&gt; group = byContract.get(contractType);&#10;            if (group != null &amp;&amp; !group.isEmpty()) {&#10;                // Dentro del mismo tipo de contrato, seleccionar el que tiene menos horas&#10;                // para mantener equidad&#10;                return selectMostEquitable(group);&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Selecciona el profesor con menos horas trabajadas (equidad).&#10;     * En caso de empate, alterna para distribuir mejor.&#10;     */&#10;    private Teacher selectMostEquitable(List&lt;Teacher&gt; teachers) {&#10;        if (teachers.size() == 1) {&#10;            return teachers.get(0);&#10;        }&#10;&#10;        // Ordenar por horas trabajadas&#10;        teachers.sort(Comparator.comparingInt(Teacher::getWorkedHours));&#10;&#10;        // Si hay varios con las mismas horas mínimas, seleccionar aleatoriamente&#10;        int minHours = teachers.get(0).getWorkedHours();&#10;        List&lt;Teacher&gt; tied = teachers.stream()&#10;                .filter(t -&gt; t.getWorkedHours() == minHours)&#10;                .collect(Collectors.toList());&#10;&#10;        if (tied.size() &gt; 1) {&#10;            // Aleatoriedad para distribución equitativa&#10;            Collections.shuffle(tied);&#10;        }&#10;&#10;        return tied.get(0);&#10;    }&#10;&#10;    /**&#10;     * Asigna múltiples profesores para una clase que requiere varios instructores.&#10;     */&#10;    @Transactional&#10;    public List&lt;Teacher&gt; assignMultipleTeachers(Speciality speciality, int durationMinutes, int count) {&#10;        List&lt;Teacher&gt; assigned = new ArrayList&lt;&gt;();&#10;&#10;        for (int i = 0; i &lt; count; i++) {&#10;            Optional&lt;Teacher&gt; teacher = assignTeacherExcluding(speciality, durationMinutes, assigned);&#10;            teacher.ifPresent(assigned::add);&#10;        }&#10;&#10;        if (assigned.size() &lt; count) {&#10;            log.warn(&quot;Solo se pudieron asignar {} de {} profesores para {}&quot;, &#10;                assigned.size(), count, speciality);&#10;        }&#10;&#10;        return assigned;&#10;    }&#10;&#10;    /**&#10;     * Asigna un profesor excluyendo los ya asignados.&#10;     */&#10;    private Optional&lt;Teacher&gt; assignTeacherExcluding(Speciality speciality, int durationMinutes, &#10;                                                      List&lt;Teacher&gt; excluded) {&#10;        Set&lt;Long&gt; excludedIds = excluded.stream()&#10;                .map(Teacher::getId)&#10;                .collect(Collectors.toSet());&#10;&#10;        List&lt;Teacher&gt; candidates = teacherRepository.findAvailableBySpecialityOrderByPriorityAndHours(speciality)&#10;                .stream()&#10;                .filter(t -&gt; !excludedIds.contains(t.getId()))&#10;                .filter(t -&gt; t.getWorkedHours() + (durationMinutes / 60) &lt;= t.getMaxWeeklyHours())&#10;                .collect(Collectors.toList());&#10;&#10;        if (candidates.isEmpty()) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        Teacher selected = selectTeacher(candidates, durationMinutes / 60);&#10;        if (selected != null) {&#10;            selected.setWorkedHours(selected.getWorkedHours() + (durationMinutes / 60));&#10;            teacherRepository.save(selected);&#10;        }&#10;&#10;        return Optional.ofNullable(selected);&#10;    }&#10;&#10;    /**&#10;     * Reasigna un profesor cuando el actual no está disponible.&#10;     * Mantiene las reglas de prioridad pero excluye al profesor original.&#10;     */&#10;    @Transactional&#10;    public Optional&lt;Teacher&gt; reassignTeacher(Long originalTeacherId, Speciality speciality, int durationMinutes) {&#10;        log.info(&quot;Reasignando profesor para {}, profesor original: {}&quot;, speciality, originalTeacherId);&#10;&#10;        List&lt;Teacher&gt; candidates = teacherRepository.findAvailableBySpecialityOrderByPriorityAndHours(speciality)&#10;                .stream()&#10;                .filter(t -&gt; !t.getId().equals(originalTeacherId))&#10;                .filter(t -&gt; t.getWorkedHours() + (durationMinutes / 60) &lt;= t.getMaxWeeklyHours())&#10;                .collect(Collectors.toList());&#10;&#10;        if (candidates.isEmpty()) {&#10;            log.warn(&quot;No hay profesores disponibles para reasignación de {}&quot;, speciality);&#10;            return Optional.empty();&#10;        }&#10;&#10;        Teacher selected = selectTeacher(candidates, durationMinutes / 60);&#10;        if (selected != null) {&#10;            selected.setWorkedHours(selected.getWorkedHours() + (durationMinutes / 60));&#10;            teacherRepository.save(selected);&#10;            log.info(&quot;Reasignado a: {} {}&quot;, selected.getName(), selected.getLastName());&#10;        }&#10;&#10;        return Optional.ofNullable(selected);&#10;    }&#10;&#10;    /**&#10;     * Obtiene estadísticas de distribución de horas por tipo de contrato.&#10;     */&#10;    public Map&lt;ContractType, Double&gt; getHoursDistributionStats() {&#10;        Map&lt;ContractType, Double&gt; stats = new HashMap&lt;&gt;();&#10;&#10;        for (ContractType type : ContractType.values()) {&#10;            List&lt;Teacher&gt; teachers = teacherRepository.findByContractTypeOrderByWorkedHoursAsc(type);&#10;            if (!teachers.isEmpty()) {&#10;                double avgHours = teachers.stream()&#10;                        .mapToInt(Teacher::getWorkedHours)&#10;                        .average()&#10;                        .orElse(0.0);&#10;                stats.put(type, avgHours);&#10;            }&#10;        }&#10;&#10;        return stats;&#10;    }&#10;&#10;    /**&#10;     * Verifica si la distribución de horas es equitativa dentro de cada grupo.&#10;     * Retorna true si la diferencia entre el máximo y mínimo es menor al umbral.&#10;     */&#10;    public boolean isDistributionEquitable(ContractType contractType, int thresholdHours) {&#10;        List&lt;Teacher&gt; teachers = teacherRepository.findByContractTypeOrderByWorkedHoursAsc(contractType);&#10;        &#10;        if (teachers.size() &lt; 2) {&#10;            return true;&#10;        }&#10;&#10;        int minHours = teachers.get(0).getWorkedHours();&#10;        int maxHours = teachers.get(teachers.size() - 1).getWorkedHours();&#10;&#10;        return (maxHours - minHours) &lt;= thresholdHours;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/TeacherService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/java/com/empresa/teacher/MicroserviceTeacherRegisterAPI/Service/TeacherService.java" />
              <option name="updatedContent" value="package com.empresa.teacher.MicroserviceTeacherRegisterAPI.Service;&#10;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.TeacherRequest;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Controller.DTO.TeacherResponse;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.ContractType;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Enums.Speciality;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Entities.Teacher;&#10;import com.empresa.teacher.MicroserviceTeacherRegisterAPI.Repository.TeacherRepository;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Servicio para gestión de profesores&#10; */&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class TeacherService {&#10;&#10;    private final TeacherRepository teacherRepository;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    /**&#10;     * Obtener todos los profesores&#10;     */&#10;    public List&lt;TeacherResponse&gt; findAll() {&#10;        return teacherRepository.findAll().stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtener profesor por ID&#10;     */&#10;    public TeacherResponse findById(Long id) {&#10;        Teacher teacher = teacherRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + id));&#10;        return toResponse(teacher);&#10;    }&#10;&#10;    /**&#10;     * Crear profesor&#10;     */&#10;    @Transactional&#10;    public TeacherResponse create(TeacherRequest request) {&#10;        if (teacherRepository.existsByEmail(request.getEmail())) {&#10;            throw new RuntimeException(&quot;El email ya está registrado&quot;);&#10;        }&#10;        if (teacherRepository.existsByDni(request.getDni())) {&#10;            throw new RuntimeException(&quot;El DNI ya está registrado&quot;);&#10;        }&#10;&#10;        Teacher teacher = Teacher.builder()&#10;                .name(request.getName())&#10;                .lastName(request.getLastName())&#10;                .dni(request.getDni())&#10;                .phone(request.getPhone())&#10;                .email(request.getEmail())&#10;                .password(passwordEncoder.encode(request.getPassword()))&#10;                .specialities(request.getSpecialities())&#10;                .contractType(request.getContractType())&#10;                .maxWeeklyHours(request.getMaxWeeklyHours() != null ? request.getMaxWeeklyHours() : 40)&#10;                .workedHours(0)&#10;                .available(true)&#10;                .confirmedAvailability(false)&#10;                .build();&#10;&#10;        return toResponse(teacherRepository.save(teacher));&#10;    }&#10;&#10;    /**&#10;     * Actualizar profesor&#10;     */&#10;    @Transactional&#10;    public TeacherResponse update(Long id, TeacherRequest request) {&#10;        Teacher teacher = teacherRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + id));&#10;&#10;        teacher.setName(request.getName());&#10;        teacher.setLastName(request.getLastName());&#10;        teacher.setPhone(request.getPhone());&#10;        teacher.setSpecialities(request.getSpecialities());&#10;        teacher.setContractType(request.getContractType());&#10;        if (request.getMaxWeeklyHours() != null) {&#10;            teacher.setMaxWeeklyHours(request.getMaxWeeklyHours());&#10;        }&#10;&#10;        return toResponse(teacherRepository.save(teacher));&#10;    }&#10;&#10;    /**&#10;     * Eliminar profesor&#10;     */&#10;    @Transactional&#10;    public void delete(Long id) {&#10;        if (!teacherRepository.existsById(id)) {&#10;            throw new RuntimeException(&quot;Profesor no encontrado: &quot; + id);&#10;        }&#10;        teacherRepository.deleteById(id);&#10;    }&#10;&#10;    /**&#10;     * Obtener profesores disponibles por especialidad&#10;     */&#10;    public List&lt;TeacherResponse&gt; findAvailableBySpeciality(Speciality speciality) {&#10;        return teacherRepository.findAvailableBySpecialityOrderByPriorityAndHours(speciality).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Obtener profesores por tipo de contrato&#10;     */&#10;    public List&lt;TeacherResponse&gt; findByContractType(ContractType contractType) {&#10;        return teacherRepository.findByContractTypeOrderByWorkedHoursAsc(contractType).stream()&#10;                .map(this::toResponse)&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Actualizar disponibilidad&#10;     */&#10;    @Transactional&#10;    public void updateAvailability(Long id, boolean available) {&#10;        Teacher teacher = teacherRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + id));&#10;        teacher.setAvailable(available);&#10;        teacherRepository.save(teacher);&#10;    }&#10;&#10;    /**&#10;     * Confirmar disponibilidad para horario&#10;     */&#10;    @Transactional&#10;    public void confirmAvailability(Long id, boolean confirmed) {&#10;        Teacher teacher = teacherRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + id));&#10;        teacher.setConfirmedAvailability(confirmed);&#10;        if (!confirmed) {&#10;            teacher.setAvailable(false);&#10;        }&#10;        teacherRepository.save(teacher);&#10;    }&#10;&#10;    /**&#10;     * Añadir horas trabajadas&#10;     */&#10;    @Transactional&#10;    public void addWorkedHours(Long id, int hours) {&#10;        Teacher teacher = teacherRepository.findById(id)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Profesor no encontrado: &quot; + id));&#10;        teacher.setWorkedHours(teacher.getWorkedHours() + hours);&#10;        teacherRepository.save(teacher);&#10;    }&#10;&#10;    /**&#10;     * Resetear horas trabajadas (inicio de semana)&#10;     */&#10;    @Transactional&#10;    public void resetAllWorkedHours() {&#10;        List&lt;Teacher&gt; teachers = teacherRepository.findAll();&#10;        teachers.forEach(t -&gt; t.setWorkedHours(0));&#10;        teacherRepository.saveAll(teachers);&#10;    }&#10;&#10;    private TeacherResponse toResponse(Teacher teacher) {&#10;        return TeacherResponse.builder()&#10;                .id(teacher.getId())&#10;                .name(teacher.getName())&#10;                .lastName(teacher.getLastName())&#10;                .dni(teacher.getDni())&#10;                .phone(teacher.getPhone())&#10;                .email(teacher.getEmail())&#10;                .specialities(teacher.getSpecialities())&#10;                .contractType(teacher.getContractType())&#10;                .workedHours(teacher.getWorkedHours())&#10;                .maxWeeklyHours(teacher.getMaxWeeklyHours())&#10;                .available(teacher.getAvailable())&#10;                .confirmedAvailability(teacher.getConfirmedAvailability())&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/resources/application.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MicroserviceTeacherRegisterAPI/src/main/resources/application.yml" />
              <option name="originalContent" value="server:&#10;  port: 8082&#10;&#10;spring:&#10;  application:&#10;    name: msvc-teacher-api&#10;  datasource:&#10;    driver-class-name: com.mysql.cj.jdbc.Driver&#10;    url: jdbc:mysql://localhost:3306/TFGDB&#10;    username: root&#10;    password: curso&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: create-drop&#10;    database: mysql&#10;    database-platform: org.hibernate.dialect.MySQL8Dialect&#10;&#10;eureka:&#10;  instance:&#10;    hostname: localhost&#10;  client:&#10;    service-url:&#10;      defaultZone: http://localhost:8761/eureka/" />
              <option name="updatedContent" value="server:&#10;  port: 8082&#10;&#10;spring:&#10;  application:&#10;    name: msvc-teacher-api&#10;  datasource:&#10;    driver-class-name: org.postgresql.Driver&#10;    url: jdbc:postgresql://localhost:5432/tfgdb&#10;    username: postgres&#10;    password: curso&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: update&#10;    show-sql: true&#10;    database: postgresql&#10;    database-platform: org.hibernate.dialect.PostgreSQLDialect&#10;  kafka:&#10;    bootstrap-servers: localhost:29092&#10;    consumer:&#10;      group-id: teacher-group&#10;      auto-offset-reset: earliest&#10;      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer&#10;      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer&#10;      properties:&#10;        spring.json.trusted.packages: &quot;*&quot;&#10;        spring.json.type.mapping: &quot;scheduleEvent:com.empresa.teacher.MicroserviceTeacherRegisterAPI.Kafka.Events.ScheduleEvent&quot;&#10;    producer:&#10;      key-serializer: org.apache.kafka.common.serialization.StringSerializer&#10;      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer&#10;  mail:&#10;    host: smtp.gmail.com&#10;    port: 587&#10;    username: ${MAIL_USERNAME:your-email@gmail.com}&#10;    password: ${MAIL_PASSWORD:your-app-password}&#10;    properties:&#10;      mail:&#10;        smtp:&#10;          auth: true&#10;          starttls:&#10;            enable: true&#10;&#10;jwt:&#10;  secret: RVZTX0xhQW50aWxsYV9TZWNyZXRLZXlfMjAyNF9URkdfU2FpbGluZ1NjaG9vbF9KV1RfVG9rZW5fS2V5&#10;  expiration: 86400000&#10;&#10;eureka:&#10;  instance:&#10;    hostname: localhost&#10;  client:&#10;    service-url:&#10;      defaultZone: http://localhost:8761/eureka/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# EVS La Antilla - Sistema de Gestión de Escuela de Vela&#10;&#10;Sistema backend basado en microservicios para la gestión integral de una escuela de vela.&#10;&#10;## ️ Arquitectura&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────────┐&#10;│                         EVS La Antilla                               │&#10;├─────────────────────────────────────────────────────────────────────┤&#10;│                                                                      │&#10;│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐              │&#10;│  │  Teacher    │    │  Students   │    │   Course    │              │&#10;│  │   API       │    │    API      │    │    API      │              │&#10;│  │  :8082      │    │   :8081     │    │   :8083     │              │&#10;│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘              │&#10;│         │                  │                  │                      │&#10;│         └──────────────────┼──────────────────┘                      │&#10;│                            │                                         │&#10;│                    ┌───────┴───────┐                                 │&#10;│                    │    KAFKA      │                                 │&#10;│                    │   :29092      │                                 │&#10;│                    └───────────────┘                                 │&#10;│                            │                                         │&#10;│                    ┌───────┴───────┐                                 │&#10;│                    │  PostgreSQL   │                                 │&#10;│                    │    :5432      │                                 │&#10;│                    └───────────────┘                                 │&#10;│                                                                      │&#10;│                    ┌───────────────┐                                 │&#10;│                    │   Eureka      │                                 │&#10;│                    │    :8761      │                                 │&#10;│                    └───────────────┘                                 │&#10;│                                                                      │&#10;└─────────────────────────────────────────────────────────────────────┘&#10;```&#10;&#10;##  Microservicios&#10;&#10;### MicroserviceTeacherRegisterAPI (Puerto 8082)&#10;- **Autenticación**: JWT, registro y login&#10;- **CRUD de profesores**: Gestión completa&#10;- **Especialidades**: WINDSURF, CATAMARAN, MINICATA, OPTIMIST, PADDLE_SURF, KAYAK, SUMMER_CAMP, VELA_LIGERA&#10;- **Tipos de contrato**: FIJO (prioridad 1), TEMPORAL (prioridad 2), PRACTICAS (prioridad 3)&#10;- **Algoritmo de asignación**: Distribución equitativa de horas respetando prioridades&#10;- **Sistema de notificaciones**: Email para horarios y confirmaciones&#10;&#10;### MicroserviceStudentsAPI (Puerto 8081)&#10;- **CRUD de estudiantes**: Gestión completa&#10;- **Niveles de habilidad**: BEGINNER, INTERMEDIATE, ADVANCED, EXPERT&#10;- **Inscripción a cursos**: Multi-curso por estudiante&#10;- **Gestión de socios**: Diferenciación de clientes&#10;&#10;### MicroserviceCourseApi (Puerto 8083)&#10;- **CRUD de cursos**: Gestión completa&#10;- **Tipos de curso**: WINDSURF, CATAMARAN, MINICATA, etc.&#10;- **Organizador de horarios**: Algoritmo automático de planificación&#10;- **Planificador de rutas**: Genera rutas de navegación basadas en:&#10;  - Dirección y velocidad del viento&#10;  - Nivel del estudiante&#10;  - Tipo de embarcación&#10;  - Duración de la clase&#10;- **Generador de imágenes**: Dibujo visual de la ruta con viradas y bordos&#10;&#10;### MicroserviceErekaServer (Puerto 8761)&#10;- Descubrimiento de servicios&#10;- Registro de microservicios&#10;&#10;##  Inicio Rápido&#10;&#10;### Requisitos&#10;- Java 17+&#10;- Docker y Docker Compose&#10;- Maven 3.8+&#10;&#10;### 1. Levantar infraestructura&#10;```bash&#10;docker-compose up -d&#10;```&#10;&#10;Esto levanta:&#10;- PostgreSQL (puerto 5432)&#10;- Kafka + Zookeeper (puerto 29092)&#10;- Kafka UI (puerto 8090)&#10;&#10;### 2. Compilar el proyecto&#10;```bash&#10;mvn clean install -DskipTests&#10;```&#10;&#10;### 3. Ejecutar microservicios&#10;&#10;```bash&#10;# Terminal 1 - Eureka Server&#10;cd MicroserviceErekaServer&#10;mvn spring-boot:run&#10;&#10;# Terminal 2 - Teacher API&#10;cd MicroserviceTeacherRegisterAPI&#10;mvn spring-boot:run&#10;&#10;# Terminal 3 - Students API&#10;cd MicroserviceStudentsAPI&#10;mvn spring-boot:run&#10;&#10;# Terminal 4 - Course API&#10;cd MicroserviceCourseApi&#10;mvn spring-boot:run&#10;```&#10;&#10;##  Autenticación&#10;&#10;### Registrar un administrador&#10;```bash&#10;curl -X POST &quot;http://localhost:8082/api/auth/register/admin?email=admin@evs.com&amp;password=admin123&amp;name=Admin&quot;&#10;```&#10;&#10;### Registrar un profesor&#10;```bash&#10;curl -X POST http://localhost:8082/api/auth/register/teacher \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;name&quot;: &quot;Juan&quot;,&#10;    &quot;lastName&quot;: &quot;García&quot;,&#10;    &quot;dni&quot;: &quot;12345678A&quot;,&#10;    &quot;phone&quot;: &quot;666777888&quot;,&#10;    &quot;email&quot;: &quot;juan@evs.com&quot;,&#10;    &quot;password&quot;: &quot;password123&quot;,&#10;    &quot;specialities&quot;: [&quot;WINDSURF&quot;, &quot;CATAMARAN&quot;],&#10;    &quot;contractType&quot;: &quot;FIJO&quot;,&#10;    &quot;maxWeeklyHours&quot;: 40&#10;  }'&#10;```&#10;&#10;### Login&#10;```bash&#10;curl -X POST http://localhost:8082/api/auth/login \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;email&quot;: &quot;admin@evs.com&quot;,&#10;    &quot;password&quot;: &quot;admin123&quot;&#10;  }'&#10;```&#10;&#10;##  API Endpoints&#10;&#10;### Profesores&#10;| Método | Endpoint | Descripción |&#10;|--------|----------|-------------|&#10;| GET | /api/teachers | Listar todos |&#10;| GET | /api/teachers/{id} | Obtener por ID |&#10;| POST | /api/teachers | Crear profesor |&#10;| PUT | /api/teachers/{id} | Actualizar |&#10;| DELETE | /api/teachers/{id} | Eliminar |&#10;| GET | /api/teachers/available/{speciality} | Por especialidad |&#10;| POST | /api/teachers/assign | Asignar automáticamente |&#10;&#10;### Estudiantes&#10;| Método | Endpoint | Descripción |&#10;|--------|----------|-------------|&#10;| GET | /api/students | Listar todos |&#10;| GET | /api/students/{id} | Obtener por ID |&#10;| POST | /api/students | Crear estudiante |&#10;| PUT | /api/students/{id} | Actualizar |&#10;| DELETE | /api/students/{id} | Eliminar |&#10;| POST | /api/students/{id}/enroll/{courseId} | Inscribir en curso |&#10;&#10;### Cursos&#10;| Método | Endpoint | Descripción |&#10;|--------|----------|-------------|&#10;| GET | /api/courses | Listar todos |&#10;| GET | /api/courses/{id} | Obtener por ID |&#10;| POST | /api/courses | Crear curso |&#10;| PUT | /api/courses/{id} | Actualizar |&#10;| DELETE | /api/courses/{id} | Eliminar |&#10;| POST | /api/courses/generate-route | Generar plan de ruta |&#10;| POST | /api/courses/organize-week | Organizar horarios semanales |&#10;&#10;##  Planificador de Rutas&#10;&#10;El sistema genera planes de navegación inteligentes:&#10;&#10;### Ejemplo de solicitud&#10;```bash&#10;curl -X POST http://localhost:8083/api/courses/generate-route \&#10;  -H &quot;Authorization: Bearer {token}&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;courseType&quot;: &quot;WINDSURF&quot;,&#10;    &quot;windDirection&quot;: &quot;SW&quot;,&#10;    &quot;windSpeedKnots&quot;: 12,&#10;    &quot;classDurationMinutes&quot;: 60,&#10;    &quot;studentLevel&quot;: 2&#10;  }'&#10;```&#10;&#10;### Respuesta&#10;- Lista de tramos (legs) con rumbo, duración y distancia&#10;- Tipos de maniobra: VIRADA, TRASLUCHADA, CEÑIDA, TRAVES, LARGO, POPA&#10;- Imagen en Base64 del recorrido&#10;- Notas de seguridad&#10;- Resumen del plan&#10;&#10;##  Algoritmo de Asignación de Profesores&#10;&#10;El sistema asigna profesores siguiendo estas reglas:&#10;&#10;1. **Prioridad por tipo de contrato**:&#10;   - FIJO (prioridad 1)&#10;   - TEMPORAL (prioridad 2)&#10;   - PRACTICAS (prioridad 3)&#10;&#10;2. **Equidad dentro del mismo nivel**:&#10;   - Se asigna al profesor con menos horas trabajadas&#10;   - Si hay empate, se alterna aleatoriamente&#10;&#10;3. **Restricciones**:&#10;   - Solo profesores con la especialidad requerida&#10;   - Solo profesores disponibles&#10;   - No superar horas máximas semanales&#10;&#10;##  Sistema de Notificaciones&#10;&#10;- Envío de horarios semanales por email&#10;- Solicitud de confirmación de disponibilidad&#10;- Recordatorios automáticos&#10;- Notificación de reasignaciones&#10;- Envío de planes de ruta&#10;&#10;## ️ Base de Datos&#10;&#10;Todas las tablas están en PostgreSQL con esquema unificado:&#10;&#10;- `users` - Usuarios del sistema&#10;- `teachers` - Profesores con especialidades&#10;- `students` - Estudiantes con niveles&#10;- `courses` - Cursos y tipos&#10;- `schedules` - Horarios&#10;- `route_plans` - Planes de navegación&#10;- `route_legs` - Tramos de rutas&#10;- `nautical_zones` - Zonas del canal náutico&#10;&#10;##  Kafka Topics&#10;&#10;- `teacher-events` - Eventos de profesores&#10;- `student-events` - Eventos de estudiantes&#10;- `course-events` - Eventos de cursos&#10;- `schedule-events` - Eventos de horarios&#10;- `notification-events` - Eventos de notificaciones&#10;&#10;##  Configuración&#10;&#10;Variables de entorno importantes:&#10;&#10;```yaml&#10;# Base de datos&#10;POSTGRES_HOST: localhost&#10;POSTGRES_PORT: 5432&#10;POSTGRES_DB: tfgdb&#10;POSTGRES_USER: postgres&#10;POSTGRES_PASSWORD: curso&#10;&#10;# Kafka&#10;KAFKA_BOOTSTRAP_SERVERS: localhost:29092&#10;&#10;# JWT&#10;JWT_SECRET: EVS_LaAntilla_SecretKey_2024_TFG_SailingSchool_JWT_Token_Key&#10;JWT_EXPIRATION: 86400000&#10;&#10;# Mail (opcional)&#10;MAIL_USERNAME: your-email@gmail.com&#10;MAIL_PASSWORD: your-app-password&#10;```&#10;&#10;##  Estructura del Proyecto&#10;&#10;```&#10;TFG_BACK/&#10;├── docker-compose.yml&#10;├── pom.xml&#10;├── MicroserviceErekaServer/&#10;├── MicroserviceTeacherRegisterAPI/&#10;│   └── src/main/java/.../&#10;│       ├── Controller/&#10;│       ├── Entities/&#10;│       ├── Repository/&#10;│       ├── Service/&#10;│       ├── Security/&#10;│       └── Kafka/&#10;├── MicroserviceStudentsAPI/&#10;│   └── src/main/java/.../&#10;│       ├── Controller/&#10;│       ├── Entities/&#10;│       ├── Repository/&#10;│       ├── Service/&#10;│       └── Security/&#10;└── MicroserviceCourseApi/&#10;    └── src/main/java/.../&#10;        ├── Controller/&#10;        ├── Entities/&#10;        ├── Repository/&#10;        ├── Service/&#10;        ├── Security/&#10;        └── Kafka/&#10;```&#10;&#10;##  Autor&#10;&#10;Proyecto TFG - Escuela de Vela La Antilla&#10;&#10;##  Licencia&#10;&#10;Proyecto académico - DAM&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="updatedContent" value="version: '3.8'&#10;&#10;services:&#10;  # Base de datos PostgreSQL unificada&#10;  postgres:&#10;    image: postgres:15&#10;    container_name: evs-postgres&#10;    environment:&#10;      POSTGRES_DB: tfgdb&#10;      POSTGRES_USER: postgres&#10;      POSTGRES_PASSWORD: curso&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    volumes:&#10;      - postgres_data:/var/lib/postgresql/data&#10;    networks:&#10;      - evs-network&#10;&#10;  # Zookeeper para Kafka&#10;  zookeeper:&#10;    image: confluentinc/cp-zookeeper:7.5.0&#10;    container_name: evs-zookeeper&#10;    environment:&#10;      ZOOKEEPER_CLIENT_PORT: 2181&#10;      ZOOKEEPER_TICK_TIME: 2000&#10;    ports:&#10;      - &quot;2181:2181&quot;&#10;    networks:&#10;      - evs-network&#10;&#10;  # Kafka Broker&#10;  kafka:&#10;    image: confluentinc/cp-kafka:7.5.0&#10;    container_name: evs-kafka&#10;    depends_on:&#10;      - zookeeper&#10;    ports:&#10;      - &quot;9092:9092&quot;&#10;      - &quot;29092:29092&quot;&#10;    environment:&#10;      KAFKA_BROKER_ID: 1&#10;      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181&#10;      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092&#10;      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT&#10;      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT&#10;      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1&#10;      KAFKA_AUTO_CREATE_TOPICS_ENABLE: &quot;true&quot;&#10;    networks:&#10;      - evs-network&#10;&#10;  # Kafka UI para monitorización (opcional)&#10;  kafka-ui:&#10;    image: provectuslabs/kafka-ui:latest&#10;    container_name: evs-kafka-ui&#10;    depends_on:&#10;      - kafka&#10;    ports:&#10;      - &quot;8090:8080&quot;&#10;    environment:&#10;      KAFKA_CLUSTERS_0_NAME: evs-cluster&#10;      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092&#10;      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181&#10;    networks:&#10;      - evs-network&#10;&#10;volumes:&#10;  postgres_data:&#10;&#10;networks:&#10;  evs-network:&#10;    driver: bridge&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;            xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.2.4&lt;/version&gt;&#10;    &lt;/parent&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;name&gt;TFG_BACK&lt;/name&gt;&#10;    &lt;packaging&gt;pom&lt;/packaging&gt;&#10;&#10;    &lt;modules&gt;&#10;        &lt;module&gt;MicroserviceErekaServer&lt;/module&gt;&#10;        &lt;module&gt;MicroserviceStudentsAPI&lt;/module&gt;&#10;        &lt;module&gt;MicroserviceTeacherRegisterAPI&lt;/module&gt;&#10;        &lt;module&gt;MicroserviceCourseApi&lt;/module&gt;&#10;    &lt;/modules&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;version&gt;1.18.34&lt;/version&gt;&#10;            &lt;scope&gt;provided&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;pluginManagement&gt;&#10;            &lt;plugins&gt;&#10;                &lt;plugin&gt;&#10;                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;                    &lt;version&gt;3.2.4&lt;/version&gt;&#10;                &lt;/plugin&gt;&#10;            &lt;/plugins&gt;&#10;        &lt;/pluginManagement&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;            xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;parent&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#10;        &lt;version&gt;3.2.4&lt;/version&gt;&#10;    &lt;/parent&gt;&#10;&#10;    &lt;groupId&gt;org.example&lt;/groupId&gt;&#10;    &lt;artifactId&gt;TFG_BACK&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;&#10;    &lt;name&gt;TFG_BACK&lt;/name&gt;&#10;    &lt;packaging&gt;pom&lt;/packaging&gt;&#10;&#10;    &lt;modules&gt;&#10;        &lt;module&gt;MicroserviceErekaServer&lt;/module&gt;&#10;        &lt;module&gt;MicroserviceStudentsAPI&lt;/module&gt;&#10;        &lt;module&gt;MicroserviceTeacherRegisterAPI&lt;/module&gt;&#10;        &lt;module&gt;MicroserviceCourseApi&lt;/module&gt;&#10;    &lt;/modules&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;&#10;        &lt;jjwt.version&gt;0.12.3&lt;/jjwt.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&#10;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;&#10;            &lt;version&gt;1.18.34&lt;/version&gt;&#10;            &lt;scope&gt;provided&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;dependencyManagement&gt;&#10;        &lt;dependencies&gt;&#10;            &lt;!-- Spring Cloud --&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&#10;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&#10;                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;&#10;                &lt;type&gt;pom&lt;/type&gt;&#10;                &lt;scope&gt;import&lt;/scope&gt;&#10;            &lt;/dependency&gt;&#10;            &lt;!-- JWT --&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;                &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;&#10;                &lt;version&gt;${jjwt.version}&lt;/version&gt;&#10;            &lt;/dependency&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;                &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;&#10;                &lt;version&gt;${jjwt.version}&lt;/version&gt;&#10;            &lt;/dependency&gt;&#10;            &lt;dependency&gt;&#10;                &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;&#10;                &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;&#10;                &lt;version&gt;${jjwt.version}&lt;/version&gt;&#10;            &lt;/dependency&gt;&#10;        &lt;/dependencies&gt;&#10;    &lt;/dependencyManagement&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;pluginManagement&gt;&#10;            &lt;plugins&gt;&#10;                &lt;plugin&gt;&#10;                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#10;                    &lt;version&gt;3.2.4&lt;/version&gt;&#10;                &lt;/plugin&gt;&#10;            &lt;/plugins&gt;&#10;        &lt;/pluginManagement&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>